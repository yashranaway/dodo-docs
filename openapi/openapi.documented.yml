openapi: 3.1.0
info:
  title: public
  description: ''
  license:
    name: Apache 2.0
  version: 1.42.0
servers:
  - url: https://test.dodopayments.com/
    description: Test Mode Server Host
  - url: https://live.dodopayments.com/
    description: Live Mode Server Host
paths:
  /addons:
    get:
      tags:
        - Addons
      operationId: list_addons
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
      responses:
        '200':
          description: List all addons
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const addonResponse of client.addons.list()) {
              console.log(addonResponse.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.addons.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Addons.List(context.TODO(), dodopayments.AddonListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.addons.AddonListPage;
            import com.dodopayments.api.models.addons.AddonListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    AddonListPage page = client.addons().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.addons.AddonListPage
            import com.dodopayments.api.models.addons.AddonListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: AddonListPage = client.addons().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.addons.list

            puts(page)
    post:
      tags:
        - Addons
      operationId: create_addon
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateAddonRequest'
        required: true
      responses:
        '200':
          description: Create a new addon
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const addonResponse = await client.addons.create({
              currency: 'AED',
              name: 'name',
              price: 0,
              tax_category: 'digital_products',
            });

            console.log(addonResponse.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            addon_response = client.addons.create(
                currency="AED",
                name="name",
                price=0,
                tax_category="digital_products",
            )
            print(addon_response.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              addonResponse, err := client.Addons.New(context.TODO(), dodopayments.AddonNewParams{
                Currency: dodopayments.F(dodopayments.CurrencyAed),
                Name: dodopayments.F("name"),
                Price: dodopayments.F(int64(0)),
                TaxCategory: dodopayments.F(dodopayments.TaxCategoryDigitalProducts),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", addonResponse.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.addons.AddonCreateParams;
            import com.dodopayments.api.models.addons.AddonResponse;
            import com.dodopayments.api.models.misc.Currency;
            import com.dodopayments.api.models.misc.TaxCategory;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    AddonCreateParams params = AddonCreateParams.builder()
                        .currency(Currency.AED)
                        .name("name")
                        .price(0)
                        .taxCategory(TaxCategory.DIGITAL_PRODUCTS)
                        .build();
                    AddonResponse addonResponse = client.addons().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.addons.AddonCreateParams
            import com.dodopayments.api.models.addons.AddonResponse
            import com.dodopayments.api.models.misc.Currency
            import com.dodopayments.api.models.misc.TaxCategory

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: AddonCreateParams = AddonCreateParams.builder()
                    .currency(Currency.AED)
                    .name("name")
                    .price(0)
                    .taxCategory(TaxCategory.DIGITAL_PRODUCTS)
                    .build()
                val addonResponse: AddonResponse = client.addons().create(params)
            }
        - lang: Ruby
          source: >-
            require "dodopayments"


            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )


            addon_response = dodo_payments.addons.create(currency: :AED, name: "name", price: 0, tax_category:
            :digital_products)


            puts(addon_response)
  /addons/{id}:
    get:
      tags:
        - Addons
      operationId: get_addon_handler
      parameters:
        - name: id
          in: path
          description: Addon Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Retrieve a specific addon
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const addonResponse = await client.addons.retrieve('id');

            console.log(addonResponse.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            addon_response = client.addons.retrieve(
                "id",
            )
            print(addon_response.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              addonResponse, err := client.Addons.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", addonResponse.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.addons.AddonResponse;
            import com.dodopayments.api.models.addons.AddonRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    AddonResponse addonResponse = client.addons().retrieve("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.addons.AddonResponse
            import com.dodopayments.api.models.addons.AddonRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val addonResponse: AddonResponse = client.addons().retrieve("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            addon_response = dodo_payments.addons.retrieve("id")

            puts(addon_response)
    patch:
      tags:
        - Addons
      operationId: patch_addon
      parameters:
        - name: id
          in: path
          description: Addon Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchAddonRequest'
        required: true
      responses:
        '200':
          description: Patch update an addon
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const addonResponse = await client.addons.update('id');

            console.log(addonResponse.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            addon_response = client.addons.update(
                id="id",
            )
            print(addon_response.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              addonResponse, err := client.Addons.Update(
                context.TODO(),
                "id",
                dodopayments.AddonUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", addonResponse.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.addons.AddonResponse;
            import com.dodopayments.api.models.addons.AddonUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    AddonResponse addonResponse = client.addons().update("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.addons.AddonResponse
            import com.dodopayments.api.models.addons.AddonUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val addonResponse: AddonResponse = client.addons().update("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            addon_response = dodo_payments.addons.update("id")

            puts(addon_response)
  /addons/{id}/images:
    put:
      tags:
        - Addons
      operationId: update_addon_image
      parameters:
        - name: id
          in: path
          description: Addon Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Generate presigned upload URL for addon image
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UpdateAddonImageResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.addons.updateImages('id');

            console.log(response.image_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.addons.update_images(
                "id",
            )
            print(response.image_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Addons.UpdateImages(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.ImageID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.addons.AddonUpdateImagesParams;
            import com.dodopayments.api.models.addons.AddonUpdateImagesResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    AddonUpdateImagesResponse response = client.addons().updateImages("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.addons.AddonUpdateImagesParams
            import com.dodopayments.api.models.addons.AddonUpdateImagesResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val response: AddonUpdateImagesResponse = client.addons().updateImages("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.addons.update_images("id")

            puts(response)
  /brands:
    get:
      tags:
        - Brands
      operationId: list_brands_handler
      responses:
        '200':
          description: List all brands
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListBrandsResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brands = await client.brands.list();

            console.log(brands.items);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brands = client.brands.list()
            print(brands.items)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brands, err := client.Brands.List(context.TODO())
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brands.Items)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.brands.BrandListParams;
            import com.dodopayments.api.models.brands.BrandListResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    BrandListResponse brands = client.brands().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.brands.BrandListParams
            import com.dodopayments.api.models.brands.BrandListResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val brands: BrandListResponse = client.brands().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brands = dodo_payments.brands.list

            puts(brands)
    post:
      tags:
        - Brands
      operationId: create_brand_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateBrandRequest'
        required: true
      responses:
        '200':
          description: Created Brand
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BrandResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brand = await client.brands.create();

            console.log(brand.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brand = client.brands.create()
            print(brand.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brand, err := client.Brands.New(context.TODO(), dodopayments.BrandNewParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brand.BrandID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.brands.BrandCreateParams;
            import com.dodopayments.api.models.brands.BrandCreateResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    BrandCreateResponse brand = client.brands().create();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.brands.BrandCreateParams
            import com.dodopayments.api.models.brands.BrandCreateResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val brand: BrandCreateResponse = client.brands().create()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brand = dodo_payments.brands.create

            puts(brand)
  /brands/{id}:
    get:
      tags:
        - Brands
      summary: Thin handler just calls `get_brand` and wraps in `Json(...)`
      operationId: get_brand_handler
      parameters:
        - name: id
          in: path
          description: Brand Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Get a single brand
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BrandResponse'
        '404':
          description: Brand not found
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brand = await client.brands.retrieve('id');

            console.log(brand.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brand = client.brands.retrieve(
                "id",
            )
            print(brand.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brand, err := client.Brands.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brand.BrandID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.brands.BrandRetrieveParams;
            import com.dodopayments.api.models.brands.BrandRetrieveResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    BrandRetrieveResponse brand = client.brands().retrieve("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.brands.BrandRetrieveParams
            import com.dodopayments.api.models.brands.BrandRetrieveResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val brand: BrandRetrieveResponse = client.brands().retrieve("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brand = dodo_payments.brands.retrieve("id")

            puts(brand)
    patch:
      tags:
        - Brands
      operationId: patch_brand_handler
      parameters:
        - name: id
          in: path
          description: Brand Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchBrandRequest'
        required: true
      responses:
        '200':
          description: Updated Brand
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BrandResponse'
        '403':
          description: Primary brand cannot be updated via this API endpoint
        '404':
          description: Brand not found
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brand = await client.brands.update('id');

            console.log(brand.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brand = client.brands.update(
                id="id",
            )
            print(brand.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brand, err := client.Brands.Update(
                context.TODO(),
                "id",
                dodopayments.BrandUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brand.BrandID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.brands.BrandUpdateParams;
            import com.dodopayments.api.models.brands.BrandUpdateResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    BrandUpdateResponse brand = client.brands().update("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.brands.BrandUpdateParams
            import com.dodopayments.api.models.brands.BrandUpdateResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val brand: BrandUpdateResponse = client.brands().update("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brand = dodo_payments.brands.update("id")

            puts(brand)
  /brands/{id}/images:
    put:
      tags:
        - Brands
      operationId: update_brand_image
      parameters:
        - name: id
          in: path
          description: Brand Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Generate presigned upload URL for brand image
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UpdateBrandImageResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.brands.updateImages('id');

            console.log(response.image_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.brands.update_images(
                "id",
            )
            print(response.image_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Brands.UpdateImages(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.ImageID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.brands.BrandUpdateImagesParams;
            import com.dodopayments.api.models.brands.BrandUpdateImagesResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    BrandUpdateImagesResponse response = client.brands().updateImages("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.brands.BrandUpdateImagesParams
            import com.dodopayments.api.models.brands.BrandUpdateImagesResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val response: BrandUpdateImagesResponse = client.brands().updateImages("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.brands.update_images("id")

            puts(response)
  /checkout/supported_countries:
    get:
      tags:
        - Checkout
      operationId: get_supported_countries_proxy
      responses:
        '200':
          description: Currently Supported Countries
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/CountryCodeAlpha2'
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const countryCodes = await client.misc.listSupportedCountries();

            console.log(countryCodes);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            country_codes = client.misc.list_supported_countries()
            print(country_codes)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              countryCodes, err := client.Misc.ListSupportedCountries(context.TODO())
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", countryCodes)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.misc.CountryCode;
            import com.dodopayments.api.models.misc.MiscListSupportedCountriesParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    List<CountryCode> countryCodes = client.misc().listSupportedCountries();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.misc.CountryCode
            import com.dodopayments.api.models.misc.MiscListSupportedCountriesParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val countryCodes: List<CountryCode> = client.misc().listSupportedCountries()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            country_codes = dodo_payments.misc.list_supported_countries

            puts(country_codes)
  /customers:
    get:
      tags:
        - Customers
      operationId: list_customers
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: email
          in: query
          description: Filter by customer email
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: Customers List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetCustomersListResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const customer of client.customers.list()) {
              console.log(customer.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.customers.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Customers.List(context.TODO(), dodopayments.CustomerListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.customers.CustomerListPage;
            import com.dodopayments.api.models.customers.CustomerListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    CustomerListPage page = client.customers().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.customers.CustomerListPage
            import com.dodopayments.api.models.customers.CustomerListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: CustomerListPage = client.customers().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.customers.list

            puts(page)
    post:
      tags:
        - Customers
      operationId: create_customer
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateCustomerRequest'
        required: true
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CustomerResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customer = await client.customers.create({ email: 'email', name: 'name' });

            console.log(customer.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer = client.customers.create(
                email="email",
                name="name",
            )
            print(customer.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customer, err := client.Customers.New(context.TODO(), dodopayments.CustomerNewParams{
                Email: dodopayments.F("email"),
                Name: dodopayments.F("name"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customer.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.customers.Customer;
            import com.dodopayments.api.models.customers.CustomerCreateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    CustomerCreateParams params = CustomerCreateParams.builder()
                        .email("email")
                        .name("name")
                        .build();
                    Customer customer = client.customers().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.customers.Customer
            import com.dodopayments.api.models.customers.CustomerCreateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: CustomerCreateParams = CustomerCreateParams.builder()
                    .email("email")
                    .name("name")
                    .build()
                val customer: Customer = client.customers().create(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer = dodo_payments.customers.create(email: "email", name: "name")

            puts(customer)
  /customers/{customer_id}:
    get:
      tags:
        - Customers
      operationId: get_customer_handler
      parameters:
        - name: customer_id
          in: path
          description: Customer Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CustomerResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customer = await client.customers.retrieve('customer_id');

            console.log(customer.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer = client.customers.retrieve(
                "customer_id",
            )
            print(customer.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customer, err := client.Customers.Get(context.TODO(), "customer_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customer.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.customers.Customer;
            import com.dodopayments.api.models.customers.CustomerRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Customer customer = client.customers().retrieve("customer_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.customers.Customer
            import com.dodopayments.api.models.customers.CustomerRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val customer: Customer = client.customers().retrieve("customer_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer = dodo_payments.customers.retrieve("customer_id")

            puts(customer)
    patch:
      tags:
        - Customers
      operationId: patch_customer
      parameters:
        - name: customer_id
          in: path
          description: Customer Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchCustomerRequest'
        required: true
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CustomerResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customer = await client.customers.update('customer_id');

            console.log(customer.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer = client.customers.update(
                customer_id="customer_id",
            )
            print(customer.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customer, err := client.Customers.Update(
                context.TODO(),
                "customer_id",
                dodopayments.CustomerUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customer.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.customers.Customer;
            import com.dodopayments.api.models.customers.CustomerUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Customer customer = client.customers().update("customer_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.customers.Customer
            import com.dodopayments.api.models.customers.CustomerUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val customer: Customer = client.customers().update("customer_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer = dodo_payments.customers.update("customer_id")

            puts(customer)
  /customers/{customer_id}/customer-portal/session:
    post:
      tags:
        - Customers
      operationId: create_customer_portal_session
      parameters:
        - name: send_email
          in: query
          description: If true, will send link to user.
          required: false
          schema:
            type: boolean
          style: form
        - name: customer_id
          in: path
          description: Customer Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successfully send email to customer (if they exist)
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateCustomerPortalSessionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customerPortalSession = await client.customers.customerPortal.create('customer_id');

            console.log(customerPortalSession.link);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer_portal_session = client.customers.customer_portal.create(
                customer_id="customer_id",
            )
            print(customer_portal_session.link)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customerPortalSession, err := client.Customers.CustomerPortal.New(
                context.TODO(),
                "customer_id",
                dodopayments.CustomerCustomerPortalNewParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customerPortalSession.Link)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.customers.CustomerPortalSession;
            import com.dodopayments.api.models.customers.customerportal.CustomerPortalCreateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    CustomerPortalSession customerPortalSession = client.customers().customerPortal().create("customer_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.customers.CustomerPortalSession
            import com.dodopayments.api.models.customers.customerportal.CustomerPortalCreateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val customerPortalSession: CustomerPortalSession = client.customers().customerPortal().create("customer_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer_portal_session = dodo_payments.customers.customer_portal.create("customer_id")

            puts(customer_portal_session)
  /discounts:
    get:
      tags:
        - Discounts
      summary: GET /discounts
      operationId: list_discounts_handler
      parameters:
        - name: page_size
          in: query
          description: Page size (default = 10, max = 100).
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number (default = 0).
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
      responses:
        '200':
          description: List of active Discounts
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetDiscountsListResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const discount of client.discounts.list()) {
              console.log(discount.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.discounts.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Discounts.List(context.TODO(), dodopayments.DiscountListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.discounts.DiscountListPage;
            import com.dodopayments.api.models.discounts.DiscountListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    DiscountListPage page = client.discounts().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.discounts.DiscountListPage
            import com.dodopayments.api.models.discounts.DiscountListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: DiscountListPage = client.discounts().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.discounts.list

            puts(page)
    post:
      tags:
        - Discounts
      summary: |-
        POST /discounts
        If `code` is omitted or empty, a random 16-char uppercase code is generated.
      operationId: create_discount_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateDiscountRequest'
        required: true
      responses:
        '200':
          description: Created discount
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiscountResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const discount = await client.discounts.create({ amount: 0, type: 'percentage' });

            console.log(discount.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            discount = client.discounts.create(
                amount=0,
                type="percentage",
            )
            print(discount.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              discount, err := client.Discounts.New(context.TODO(), dodopayments.DiscountNewParams{
                Amount: dodopayments.F(int64(0)),
                Type: dodopayments.F(dodopayments.DiscountTypePercentage),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", discount.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.discounts.Discount;
            import com.dodopayments.api.models.discounts.DiscountCreateParams;
            import com.dodopayments.api.models.discounts.DiscountType;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    DiscountCreateParams params = DiscountCreateParams.builder()
                        .amount(0)
                        .type(DiscountType.PERCENTAGE)
                        .build();
                    Discount discount = client.discounts().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.discounts.Discount
            import com.dodopayments.api.models.discounts.DiscountCreateParams
            import com.dodopayments.api.models.discounts.DiscountType

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: DiscountCreateParams = DiscountCreateParams.builder()
                    .amount(0)
                    .type(DiscountType.PERCENTAGE)
                    .build()
                val discount: Discount = client.discounts().create(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            discount = dodo_payments.discounts.create(amount: 0, type: :percentage)

            puts(discount)
  /discounts/{discount_id}:
    get:
      tags:
        - Discounts
      summary: GET /discounts/{discount_id}
      operationId: get_discount_handler
      parameters:
        - name: discount_id
          in: path
          description: Discount Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Fetched discount by ID
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiscountResponse'
        '404':
          description: Not found / or soft-deleted
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const discount = await client.discounts.retrieve('discount_id');

            console.log(discount.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            discount = client.discounts.retrieve(
                "discount_id",
            )
            print(discount.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              discount, err := client.Discounts.Get(context.TODO(), "discount_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", discount.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.discounts.Discount;
            import com.dodopayments.api.models.discounts.DiscountRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Discount discount = client.discounts().retrieve("discount_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.discounts.Discount
            import com.dodopayments.api.models.discounts.DiscountRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val discount: Discount = client.discounts().retrieve("discount_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            discount = dodo_payments.discounts.retrieve("discount_id")

            puts(discount)
    delete:
      tags:
        - Discounts
      summary: DELETE /discounts/{discount_id}
      operationId: delete_discount_handler
      parameters:
        - name: discount_id
          in: path
          description: Discount Id
          required: true
          schema:
            type: string
      responses:
        '204':
          description: Soft-deleted discount (no content)
        '404':
          description: Discount not found or already deleted
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.discounts.delete('discount_id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.discounts.delete(
                "discount_id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Discounts.Delete(context.TODO(), "discount_id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.discounts.DiscountDeleteParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    client.discounts().delete("discount_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.discounts.DiscountDeleteParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                client.discounts().delete("discount_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.discounts.delete("discount_id")

            puts(result)
    patch:
      tags:
        - Discounts
      summary: PATCH /discounts/{discount_id}
      operationId: patch_discount_handler
      parameters:
        - name: discount_id
          in: path
          description: Discount Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchDiscountRequest'
        required: true
      responses:
        '200':
          description: Updated discount
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiscountResponse'
        '404':
          description: Discount not found or soft-deleted
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const discount = await client.discounts.update('discount_id');

            console.log(discount.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            discount = client.discounts.update(
                discount_id="discount_id",
            )
            print(discount.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              discount, err := client.Discounts.Update(
                context.TODO(),
                "discount_id",
                dodopayments.DiscountUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", discount.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.discounts.Discount;
            import com.dodopayments.api.models.discounts.DiscountUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Discount discount = client.discounts().update("discount_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.discounts.Discount
            import com.dodopayments.api.models.discounts.DiscountUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val discount: Discount = client.discounts().update("discount_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            discount = dodo_payments.discounts.update("discount_id")

            puts(discount)
  /disputes:
    get:
      tags:
        - Disputes
      operationId: list_disputes
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: dispute_status
          in: query
          description: Filter by dispute status
          required: false
          schema:
            type: string
            enum:
              - dispute_opened
              - dispute_expired
              - dispute_accepted
              - dispute_cancelled
              - dispute_challenged
              - dispute_won
              - dispute_lost
          style: form
        - name: dispute_stage
          in: query
          description: Filter by dispute stage
          required: false
          schema:
            type: string
            enum:
              - pre_dispute
              - dispute
              - pre_arbitration
          style: form
        - name: customer_id
          in: query
          description: Filter by customer_id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetDisputesListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const disputeListResponse of client.disputes.list()) {
              console.log(disputeListResponse.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.disputes.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Disputes.List(context.TODO(), dodopayments.DisputeListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.disputes.DisputeListPage;
            import com.dodopayments.api.models.disputes.DisputeListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    DisputeListPage page = client.disputes().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.disputes.DisputeListPage
            import com.dodopayments.api.models.disputes.DisputeListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: DisputeListPage = client.disputes().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.disputes.list

            puts(page)
  /disputes/{dispute_id}:
    get:
      tags:
        - Disputes
      operationId: get_dispute_handler
      parameters:
        - name: dispute_id
          in: path
          description: Dispute Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetDisputeResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const dispute = await client.disputes.retrieve('dispute_id');

            console.log(dispute.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            dispute = client.disputes.retrieve(
                "dispute_id",
            )
            print(dispute.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              dispute, err := client.Disputes.Get(context.TODO(), "dispute_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", dispute.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.disputes.DisputeRetrieveParams;
            import com.dodopayments.api.models.disputes.DisputeRetrieveResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    DisputeRetrieveResponse dispute = client.disputes().retrieve("dispute_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.disputes.DisputeRetrieveParams
            import com.dodopayments.api.models.disputes.DisputeRetrieveResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val dispute: DisputeRetrieveResponse = client.disputes().retrieve("dispute_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            dispute = dodo_payments.disputes.retrieve("dispute_id")

            puts(dispute)
  /invoices/payments/{payment_id}:
    get:
      tags:
        - Invoices
      operationId: get_payment_invoice_no_auth
      parameters:
        - name: payment_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: PDF document
          content:
            application/pdf:
              schema:
                type: array
                items:
                  type: integer
                  format: int32
                  minimum: 0
        '429':
          description: Too Many Requests have been sent
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const payment = await client.invoices.payments.retrieve('payment_id');

            console.log(payment);

            const content = await payment.blob();
            console.log(content);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            payment = client.invoices.payments.retrieve(
                "payment_id",
            )
            print(payment)
            content = payment.read()
            print(content)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              payment, err := client.Invoices.Payments.Get(context.TODO(), "payment_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", payment)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.core.http.HttpResponse;
            import com.dodopayments.api.models.invoices.payments.PaymentRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    HttpResponse payment = client.invoices().payments().retrieve("payment_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.core.http.HttpResponse
            import com.dodopayments.api.models.invoices.payments.PaymentRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val payment: HttpResponse = client.invoices().payments().retrieve("payment_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            payment = dodo_payments.invoices.payments.retrieve("payment_id")

            puts(payment)
  /license_key_instances:
    get:
      tags:
        - License Keys
      operationId: list_license_key_instances
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
            minimum: 0
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
            minimum: 0
        - name: license_key_id
          in: query
          description: Filter by license key ID
          required: false
          schema:
            type:
              - string
              - 'null'
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListLicenseKeyInstancesResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const licenseKeyInstance of client.licenseKeyInstances.list()) {
              console.log(licenseKeyInstance.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.license_key_instances.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.LicenseKeyInstances.List(context.TODO(), dodopayments.LicenseKeyInstanceListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceListPage;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseKeyInstanceListPage page = client.licenseKeyInstances().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceListPage
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: LicenseKeyInstanceListPage = client.licenseKeyInstances().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.license_key_instances.list

            puts(page)
  /license_key_instances/{id}:
    get:
      tags:
        - License Keys
      operationId: get_license_key_instance
      parameters:
        - name: id
          in: path
          description: License key instance ID
          required: true
          schema:
            type: string
          example: lki_123
      responses:
        '200':
          description: License key instance found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyInstanceResponse'
        '404':
          description: License key instance not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKeyInstance = await client.licenseKeyInstances.retrieve('lki_123');

            console.log(licenseKeyInstance.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key_instance = client.license_key_instances.retrieve(
                "id",
            )
            print(license_key_instance.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKeyInstance, err := client.LicenseKeyInstances.Get(context.TODO(), "lki_123")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKeyInstance.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstance;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseKeyInstance licenseKeyInstance = client.licenseKeyInstances().retrieve("lki_123");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstance
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val licenseKeyInstance: LicenseKeyInstance = client.licenseKeyInstances().retrieve("lki_123")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key_instance = dodo_payments.license_key_instances.retrieve("id")

            puts(license_key_instance)
    patch:
      tags:
        - License Keys
      operationId: update_license_key_instance
      parameters:
        - name: id
          in: path
          description: License key instance ID
          required: true
          schema:
            type: string
          example: lki_123
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchLicenseKeyInstanceRequest'
        required: true
      responses:
        '200':
          description: License key instance updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyInstanceResponse'
        '404':
          description: License key instance not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKeyInstance = await client.licenseKeyInstances.update('lki_123', { name: 'name' });

            console.log(licenseKeyInstance.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key_instance = client.license_key_instances.update(
                id="lki_123",
                name="name",
            )
            print(license_key_instance.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKeyInstance, err := client.LicenseKeyInstances.Update(
                context.TODO(),
                "lki_123",
                dodopayments.LicenseKeyInstanceUpdateParams{
                  Name: dodopayments.F("name"),
                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKeyInstance.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstance;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseKeyInstanceUpdateParams params = LicenseKeyInstanceUpdateParams.builder()
                        .id("lki_123")
                        .name("name")
                        .build();
                    LicenseKeyInstance licenseKeyInstance = client.licenseKeyInstances().update(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstance
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstanceUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: LicenseKeyInstanceUpdateParams = LicenseKeyInstanceUpdateParams.builder()
                    .id("lki_123")
                    .name("name")
                    .build()
                val licenseKeyInstance: LicenseKeyInstance = client.licenseKeyInstances().update(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key_instance = dodo_payments.license_key_instances.update("id", name: "name")

            puts(license_key_instance)
  /license_keys:
    get:
      tags:
        - License Keys
      operationId: list_license_keys_handler
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: customer_id
          in: query
          description: Filter by customer ID
          required: false
          schema:
            type: string
          style: form
        - name: status
          in: query
          description: Filter by license key status
          required: false
          schema:
            type: string
            enum:
              - active
              - expired
              - disabled
          style: form
        - name: product_id
          in: query
          description: Filter by product ID
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListLicenseKeysResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const licenseKey of client.licenseKeys.list()) {
              console.log(licenseKey.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.license_keys.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.LicenseKeys.List(context.TODO(), dodopayments.LicenseKeyListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeys.LicenseKeyListPage;
            import com.dodopayments.api.models.licensekeys.LicenseKeyListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseKeyListPage page = client.licenseKeys().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeys.LicenseKeyListPage
            import com.dodopayments.api.models.licensekeys.LicenseKeyListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: LicenseKeyListPage = client.licenseKeys().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.license_keys.list

            puts(page)
  /license_keys/{id}:
    get:
      tags:
        - License Keys
      operationId: get_license_key_handler
      parameters:
        - name: id
          in: path
          description: License key ID
          required: true
          schema:
            type: string
          example: lic_123
      responses:
        '200':
          description: License key found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyResponse'
        '404':
          description: License key not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKey = await client.licenseKeys.retrieve('lic_123');

            console.log(licenseKey.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key = client.license_keys.retrieve(
                "id",
            )
            print(license_key.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKey, err := client.LicenseKeys.Get(context.TODO(), "lic_123")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKey.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeys.LicenseKey;
            import com.dodopayments.api.models.licensekeys.LicenseKeyRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseKey licenseKey = client.licenseKeys().retrieve("lic_123");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeys.LicenseKey
            import com.dodopayments.api.models.licensekeys.LicenseKeyRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val licenseKey: LicenseKey = client.licenseKeys().retrieve("lic_123")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key = dodo_payments.license_keys.retrieve("id")

            puts(license_key)
    patch:
      tags:
        - License Keys
      operationId: update_license_key
      parameters:
        - name: id
          in: path
          description: License key ID
          required: true
          schema:
            type: string
          example: lic_123
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchLicenseKeyRequest'
        required: true
      responses:
        '200':
          description: License key updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyResponse'
        '400':
          description: Cannot set expiry for subscription-based license
        '404':
          description: License key not found
        '422':
          description: New activation limit is less than current instances count
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKey = await client.licenseKeys.update('lic_123');

            console.log(licenseKey.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key = client.license_keys.update(
                id="lic_123",
            )
            print(license_key.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKey, err := client.LicenseKeys.Update(
                context.TODO(),
                "lic_123",
                dodopayments.LicenseKeyUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKey.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeys.LicenseKey;
            import com.dodopayments.api.models.licensekeys.LicenseKeyUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseKey licenseKey = client.licenseKeys().update("lic_123");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeys.LicenseKey
            import com.dodopayments.api.models.licensekeys.LicenseKeyUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val licenseKey: LicenseKey = client.licenseKeys().update("lic_123")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key = dodo_payments.license_keys.update("id")

            puts(license_key)
  /licenses/activate:
    post:
      tags:
        - Licenses
      operationId: activate_license_key
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ActivateLicenseKeyRequest'
        required: true
      responses:
        '201':
          description: License key instance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyInstanceResponse'
        '403':
          description: License key cannot be activated (inactive)
        '404':
          description: License key not found
        '422':
          description: License key activation limit reached
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: >-
            import DodoPayments from 'dodopayments';


            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });


            const licenseKeyInstance = await client.licenses.activate({ license_key: 'license_key', name:
            'name' });


            console.log(licenseKeyInstance.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key_instance = client.licenses.activate(
                license_key="license_key",
                name="name",
            )
            print(license_key_instance.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKeyInstance, err := client.Licenses.Activate(context.TODO(), dodopayments.LicenseActivateParams{
                LicenseKey: dodopayments.F("license_key"),
                Name: dodopayments.F("name"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKeyInstance.ID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstance;
            import com.dodopayments.api.models.licenses.LicenseActivateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseActivateParams params = LicenseActivateParams.builder()
                        .licenseKey("license_key")
                        .name("name")
                        .build();
                    LicenseKeyInstance licenseKeyInstance = client.licenses().activate(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licensekeyinstances.LicenseKeyInstance
            import com.dodopayments.api.models.licenses.LicenseActivateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: LicenseActivateParams = LicenseActivateParams.builder()
                    .licenseKey("license_key")
                    .name("name")
                    .build()
                val licenseKeyInstance: LicenseKeyInstance = client.licenses().activate(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key_instance = dodo_payments.licenses.activate(license_key: "license_key", name: "name")

            puts(license_key_instance)
  /licenses/deactivate:
    post:
      tags:
        - Licenses
      operationId: deactivate_license_key
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DeactivateLicenseKeyRequest'
        required: true
      responses:
        '200':
          description: License key instance deactivated successfully
        '403':
          description: License key instance not found or does not belong to this license key
        '404':
          description: License key not found
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.licenses.deactivate({
              license_key: 'license_key',
              license_key_instance_id: 'license_key_instance_id',
            });
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.licenses.deactivate(
                license_key="license_key",
                license_key_instance_id="license_key_instance_id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Licenses.Deactivate(context.TODO(), dodopayments.LicenseDeactivateParams{
                LicenseKey: dodopayments.F("license_key"),
                LicenseKeyInstanceID: dodopayments.F("license_key_instance_id"),
              })
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licenses.LicenseDeactivateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseDeactivateParams params = LicenseDeactivateParams.builder()
                        .licenseKey("license_key")
                        .licenseKeyInstanceId("license_key_instance_id")
                        .build();
                    client.licenses().deactivate(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licenses.LicenseDeactivateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: LicenseDeactivateParams = LicenseDeactivateParams.builder()
                    .licenseKey("license_key")
                    .licenseKeyInstanceId("license_key_instance_id")
                    .build()
                client.licenses().deactivate(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.licenses.deactivate(
              license_key: "license_key",
              license_key_instance_id: "license_key_instance_id"
            )

            puts(result)
  /licenses/validate:
    post:
      tags:
        - Licenses
      operationId: validate_license_key
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ValidateLicenseKeyRequest'
        required: true
      responses:
        '200':
          description: License key validation result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ValidateLicenseKeyResponse'
        '422':
          description: Invalid request format
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: >-
            import DodoPayments from 'dodopayments';


            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });


            const response = await client.licenses.validate({ license_key:
            '2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43' });


            console.log(response.valid);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.licenses.validate(
                license_key="2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43",
            )
            print(response.valid)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Licenses.Validate(context.TODO(), dodopayments.LicenseValidateParams{
                LicenseKey: dodopayments.F("2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.Valid)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.licenses.LicenseValidateParams;
            import com.dodopayments.api.models.licenses.LicenseValidateResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    LicenseValidateParams params = LicenseValidateParams.builder()
                        .licenseKey("2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43")
                        .build();
                    LicenseValidateResponse response = client.licenses().validate(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.licenses.LicenseValidateParams
            import com.dodopayments.api.models.licenses.LicenseValidateResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: LicenseValidateParams = LicenseValidateParams.builder()
                    .licenseKey("2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43")
                    .build()
                val response: LicenseValidateResponse = client.licenses().validate(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.licenses.validate(license_key: "2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43")

            puts(response)
  /payments:
    get:
      tags:
        - Payments
      operationId: list_payments_handler
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: customer_id
          in: query
          description: Filter by customer id
          required: false
          schema:
            type: string
          style: form
        - name: subscription_id
          in: query
          description: Filter by subscription id
          required: false
          schema:
            type: string
          style: form
        - name: status
          in: query
          description: Filter by status
          required: false
          schema:
            type: string
            enum:
              - succeeded
              - failed
              - cancelled
              - processing
              - requires_customer_action
              - requires_merchant_action
              - requires_payment_method
              - requires_confirmation
              - requires_capture
              - partially_captured
              - partially_captured_and_capturable
          style: form
        - name: brand_id
          in: query
          description: filter by Brand id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetPaymentsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const paymentListResponse of client.payments.list()) {
              console.log(paymentListResponse.brand_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.payments.list()
            page = page.items[0]
            print(page.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Payments.List(context.TODO(), dodopayments.PaymentListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.payments.PaymentListPage;
            import com.dodopayments.api.models.payments.PaymentListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    PaymentListPage page = client.payments().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.payments.PaymentListPage
            import com.dodopayments.api.models.payments.PaymentListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: PaymentListPage = client.payments().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.payments.list

            puts(page)
    post:
      tags:
        - Payments
      operationId: create_one_time_payment_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOneTimePaymentRequest'
        required: true
      responses:
        '200':
          description: One Time payment successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateOneTimePaymentResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const payment = await client.payments.create({
              billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 'zipcode' },
              customer: { customer_id: 'customer_id' },
              product_cart: [{ product_id: 'product_id', quantity: 0 }],
            });

            console.log(payment.payment_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            payment = client.payments.create(
                billing={
                    "city": "city",
                    "country": "AF",
                    "state": "state",
                    "street": "street",
                    "zipcode": "zipcode",
                },
                customer={
                    "customer_id": "customer_id"
                },
                product_cart=[{
                    "product_id": "product_id",
                    "quantity": 0,
                }],
            )
            print(payment.payment_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              payment, err := client.Payments.New(context.TODO(), dodopayments.PaymentNewParams{
                Billing: dodopayments.F(dodopayments.BillingAddressParam{
                  City: dodopayments.F("city"),
                  Country: dodopayments.F(dodopayments.CountryCodeAf),
                  State: dodopayments.F("state"),
                  Street: dodopayments.F("street"),
                  Zipcode: dodopayments.F("zipcode"),
                }),
                Customer: dodopayments.F[dodopayments.CustomerRequestUnionParam](dodopayments.AttachExistingCustomerParam{
                  CustomerID: dodopayments.F("customer_id"),
                }),
                ProductCart: dodopayments.F([]dodopayments.OneTimeProductCartItemParam{dodopayments.OneTimeProductCartItemParam{
                  ProductID: dodopayments.F("product_id"),
                  Quantity: dodopayments.F(int64(0)),
                }}),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", payment.PaymentID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.misc.CountryCode;
            import com.dodopayments.api.models.payments.AttachExistingCustomer;
            import com.dodopayments.api.models.payments.BillingAddress;
            import com.dodopayments.api.models.payments.OneTimeProductCartItem;
            import com.dodopayments.api.models.payments.PaymentCreateParams;
            import com.dodopayments.api.models.payments.PaymentCreateResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    PaymentCreateParams params = PaymentCreateParams.builder()
                        .billing(BillingAddress.builder()
                            .city("city")
                            .country(CountryCode.AF)
                            .state("state")
                            .street("street")
                            .zipcode("zipcode")
                            .build())
                        .customer(AttachExistingCustomer.builder()
                            .customerId("customer_id")
                            .build())
                        .addProductCart(OneTimeProductCartItem.builder()
                            .productId("product_id")
                            .quantity(0)
                            .build())
                        .build();
                    PaymentCreateResponse payment = client.payments().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.misc.CountryCode
            import com.dodopayments.api.models.payments.AttachExistingCustomer
            import com.dodopayments.api.models.payments.BillingAddress
            import com.dodopayments.api.models.payments.OneTimeProductCartItem
            import com.dodopayments.api.models.payments.PaymentCreateParams
            import com.dodopayments.api.models.payments.PaymentCreateResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: PaymentCreateParams = PaymentCreateParams.builder()
                    .billing(BillingAddress.builder()
                        .city("city")
                        .country(CountryCode.AF)
                        .state("state")
                        .street("street")
                        .zipcode("zipcode")
                        .build())
                    .customer(AttachExistingCustomer.builder()
                        .customerId("customer_id")
                        .build())
                    .addProductCart(OneTimeProductCartItem.builder()
                        .productId("product_id")
                        .quantity(0)
                        .build())
                    .build()
                val payment: PaymentCreateResponse = client.payments().create(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            payment = dodo_payments.payments.create(
              billing: {city: "city", country: :AF, state: "state", street: "street", zipcode: "zipcode"},
              customer: {customer_id: "customer_id"},
              product_cart: [{product_id: "product_id", quantity: 0}]
            )

            puts(payment)
  /payments/{payment_id}:
    get:
      tags:
        - Payments
      operationId: get_payment_handler
      parameters:
        - name: payment_id
          in: path
          description: Payment Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const payment = await client.payments.retrieve('payment_id');

            console.log(payment.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            payment = client.payments.retrieve(
                "payment_id",
            )
            print(payment.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              payment, err := client.Payments.Get(context.TODO(), "payment_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", payment.BrandID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.payments.Payment;
            import com.dodopayments.api.models.payments.PaymentRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Payment payment = client.payments().retrieve("payment_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.payments.Payment
            import com.dodopayments.api.models.payments.PaymentRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val payment: Payment = client.payments().retrieve("payment_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            payment = dodo_payments.payments.retrieve("payment_id")

            puts(payment)
  /payments/{payment_id}/line-items:
    get:
      tags:
        - Payments
      operationId: get_payment_line_items_handler
      parameters:
        - name: payment_id
          in: path
          description: Payment Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentLineItemsResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.payments.retrieveLineItems('payment_id');

            console.log(response.currency);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.payments.retrieve_line_items(
                "payment_id",
            )
            print(response.currency)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Payments.GetLineItems(context.TODO(), "payment_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.Currency)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.payments.PaymentRetrieveLineItemsParams;
            import com.dodopayments.api.models.payments.PaymentRetrieveLineItemsResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    PaymentRetrieveLineItemsResponse response = client.payments().retrieveLineItems("payment_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.payments.PaymentRetrieveLineItemsParams
            import com.dodopayments.api.models.payments.PaymentRetrieveLineItemsResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val response: PaymentRetrieveLineItemsResponse = client.payments().retrieveLineItems("payment_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.payments.retrieve_line_items("payment_id")

            puts(response)
  /payouts:
    get:
      tags:
        - Payouts
      operationId: list_payouts
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
      responses:
        '200':
          description: Payouts List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetPayoutsResponseList'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const payoutListResponse of client.payouts.list()) {
              console.log(payoutListResponse.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.payouts.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Payouts.List(context.TODO(), dodopayments.PayoutListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.payouts.PayoutListPage;
            import com.dodopayments.api.models.payouts.PayoutListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    PayoutListPage page = client.payouts().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.payouts.PayoutListPage
            import com.dodopayments.api.models.payouts.PayoutListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: PayoutListPage = client.payouts().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.payouts.list

            puts(page)
  /products:
    get:
      tags:
        - Products
      operationId: list_products_handler
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: archived
          in: query
          description: List archived products
          required: false
          schema:
            type: boolean
          style: form
        - name: recurring
          in: query
          description: |-
            Filter products by pricing type:
            - `true`: Show only recurring pricing products (e.g. subscriptions)
            - `false`: Show only one-time price products
            - `null` or absent: Show both types of products
          required: false
          schema:
            type: boolean
          style: form
        - name: brand_id
          in: query
          description: filter by Brand id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: Products List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetProductsListResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const productListResponse of client.products.list()) {
              console.log(productListResponse.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.products.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Products.List(context.TODO(), dodopayments.ProductListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.ProductListPage;
            import com.dodopayments.api.models.products.ProductListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    ProductListPage page = client.products().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.ProductListPage
            import com.dodopayments.api.models.products.ProductListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: ProductListPage = client.products().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.products.list

            puts(page)
    post:
      tags:
        - Products
      operationId: create_product
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateProductRequest'
        required: true
      responses:
        '200':
          description: Product Created Successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetProductResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const product = await client.products.create({
              price: { currency: 'AED', discount: 0, price: 0, purchasing_power_parity: true, type: 'one_time_price' },
              tax_category: 'digital_products',
            });

            console.log(product.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            product = client.products.create(
                price={
                    "currency": "AED",
                    "discount": 0,
                    "price": 0,
                    "purchasing_power_parity": True,
                    "type": "one_time_price",
                },
                tax_category="digital_products",
            )
            print(product.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              product, err := client.Products.New(context.TODO(), dodopayments.ProductNewParams{
                Price: dodopayments.F[dodopayments.PriceUnionParam](dodopayments.PriceOneTimePriceParam{
                  Currency: dodopayments.F(dodopayments.CurrencyAed),
                  Discount: dodopayments.F(0.000000),
                  Price: dodopayments.F(int64(0)),
                  PurchasingPowerParity: dodopayments.F(true),
                  Type: dodopayments.F(dodopayments.PriceOneTimePriceTypeOneTimePrice),
                }),
                TaxCategory: dodopayments.F(dodopayments.TaxCategoryDigitalProducts),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", product.BrandID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.misc.Currency;
            import com.dodopayments.api.models.misc.TaxCategory;
            import com.dodopayments.api.models.products.Price;
            import com.dodopayments.api.models.products.Product;
            import com.dodopayments.api.models.products.ProductCreateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    ProductCreateParams params = ProductCreateParams.builder()
                        .price(Price.OneTimePrice.builder()
                            .currency(Currency.AED)
                            .discount(0.0f)
                            .price(0)
                            .purchasingPowerParity(true)
                            .type(Price.OneTimePrice.Type.ONE_TIME_PRICE)
                            .build())
                        .taxCategory(TaxCategory.DIGITAL_PRODUCTS)
                        .build();
                    Product product = client.products().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.misc.Currency
            import com.dodopayments.api.models.misc.TaxCategory
            import com.dodopayments.api.models.products.Price
            import com.dodopayments.api.models.products.Product
            import com.dodopayments.api.models.products.ProductCreateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: ProductCreateParams = ProductCreateParams.builder()
                    .price(Price.OneTimePrice.builder()
                        .currency(Currency.AED)
                        .discount(0.0f)
                        .price(0)
                        .purchasingPowerParity(true)
                        .type(Price.OneTimePrice.Type.ONE_TIME_PRICE)
                        .build())
                    .taxCategory(TaxCategory.DIGITAL_PRODUCTS)
                    .build()
                val product: Product = client.products().create(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            product = dodo_payments.products.create(
              price: {currency: :AED, discount: 0, price: 0, purchasing_power_parity: true, type: :one_time_price},
              tax_category: :digital_products
            )

            puts(product)
  /products/{id}:
    get:
      tags:
        - Products
      operationId: get_product_handler
      parameters:
        - name: id
          in: path
          description: Product Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Product Details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetProductResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const product = await client.products.retrieve('id');

            console.log(product.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            product = client.products.retrieve(
                "id",
            )
            print(product.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              product, err := client.Products.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", product.BrandID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.Product;
            import com.dodopayments.api.models.products.ProductRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Product product = client.products().retrieve("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.Product
            import com.dodopayments.api.models.products.ProductRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val product: Product = client.products().retrieve("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            product = dodo_payments.products.retrieve("id")

            puts(product)
    delete:
      tags:
        - Products
      operationId: delete_product
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Product Delected Successfully
        '410':
          description: Product is deleted
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.products.delete('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.products.delete(
                "id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Products.Delete(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.ProductDeleteParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    client.products().delete("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.ProductDeleteParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                client.products().delete("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.products.delete("id")

            puts(result)
    patch:
      tags:
        - Products
      operationId: patch_product
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchProductRequest'
        required: true
      responses:
        '200':
          description: Product Updated Successfully
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.products.update('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.products.update(
                id="id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Products.Update(
                context.TODO(),
                "id",
                dodopayments.ProductUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.ProductUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    client.products().update("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.ProductUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                client.products().update("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.products.update("id")

            puts(result)
  /products/{id}/files:
    put:
      tags:
        - Products
      operationId: upload_product_file
      parameters:
        - name: id
          in: path
          description: Product Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UploadProductFile'
        required: true
      responses:
        '200':
          description: Aws s3 presigned URL. Upload image to this URL within 60s
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UploadProductFileResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.products.updateFiles('id', { file_name: 'file_name' });

            console.log(response.file_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.products.update_files(
                id="id",
                file_name="file_name",
            )
            print(response.file_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Products.UpdateFiles(
                context.TODO(),
                "id",
                dodopayments.ProductUpdateFilesParams{
                  FileName: dodopayments.F("file_name"),
                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.FileID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.ProductUpdateFilesParams;
            import com.dodopayments.api.models.products.ProductUpdateFilesResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    ProductUpdateFilesParams params = ProductUpdateFilesParams.builder()
                        .id("id")
                        .fileName("file_name")
                        .build();
                    ProductUpdateFilesResponse response = client.products().updateFiles(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.ProductUpdateFilesParams
            import com.dodopayments.api.models.products.ProductUpdateFilesResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: ProductUpdateFilesParams = ProductUpdateFilesParams.builder()
                    .id("id")
                    .fileName("file_name")
                    .build()
                val response: ProductUpdateFilesResponse = client.products().updateFiles(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.products.update_files("id", file_name: "file_name")

            puts(response)
  /products/{id}/images:
    put:
      tags:
        - Products
      operationId: update_product_image
      parameters:
        - name: id
          in: path
          description: Product Id
          required: true
          schema:
            type: string
        - name: force_update
          in: query
          required: false
          schema:
            type: boolean
          style: form
      responses:
        '200':
          description: Aws s3 presigned URL. Upload image to this URL within 60s
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UpdateProductImageResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const image = await client.products.images.update('id');

            console.log(image.image_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            image = client.products.images.update(
                id="id",
            )
            print(image.image_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              image, err := client.Products.Images.Update(
                context.TODO(),
                "id",
                dodopayments.ProductImageUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", image.ImageID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.images.ImageUpdateParams;
            import com.dodopayments.api.models.products.images.ImageUpdateResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    ImageUpdateResponse image = client.products().images().update("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.images.ImageUpdateParams
            import com.dodopayments.api.models.products.images.ImageUpdateResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val image: ImageUpdateResponse = client.products().images().update("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            image = dodo_payments.products.images.update("id")

            puts(image)
  /products/{id}/unarchive:
    post:
      tags:
        - Products
      operationId: undelete_product
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Product Delected Successfully
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.products.unarchive('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.products.unarchive(
                "id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Products.Unarchive(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.products.ProductUnarchiveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    client.products().unarchive("id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.products.ProductUnarchiveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                client.products().unarchive("id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.products.unarchive("id")

            puts(result)
  /refunds:
    get:
      tags:
        - Refunds
      operationId: list_refunds
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: status
          in: query
          description: Filter by status
          required: false
          schema:
            type: string
            enum:
              - succeeded
              - failed
              - pending
              - review
          style: form
        - name: customer_id
          in: query
          description: Filter by customer_id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetRefundsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const refund of client.refunds.list()) {
              console.log(refund.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.refunds.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Refunds.List(context.TODO(), dodopayments.RefundListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.refunds.RefundListPage;
            import com.dodopayments.api.models.refunds.RefundListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    RefundListPage page = client.refunds().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.refunds.RefundListPage
            import com.dodopayments.api.models.refunds.RefundListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: RefundListPage = client.refunds().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.refunds.list

            puts(page)
    post:
      tags:
        - Refunds
      operationId: create_refund_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateRefundRequest'
        required: true
      responses:
        '200':
          description: Refund successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RefundResponse'
        '400':
          description: Invalid Request Parameters
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const refund = await client.refunds.create({ payment_id: 'payment_id' });

            console.log(refund.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            refund = client.refunds.create(
                payment_id="payment_id",
            )
            print(refund.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              refund, err := client.Refunds.New(context.TODO(), dodopayments.RefundNewParams{
                PaymentID: dodopayments.F("payment_id"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", refund.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.refunds.Refund;
            import com.dodopayments.api.models.refunds.RefundCreateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    RefundCreateParams params = RefundCreateParams.builder()
                        .paymentId("payment_id")
                        .build();
                    Refund refund = client.refunds().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.refunds.Refund
            import com.dodopayments.api.models.refunds.RefundCreateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: RefundCreateParams = RefundCreateParams.builder()
                    .paymentId("payment_id")
                    .build()
                val refund: Refund = client.refunds().create(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            refund = dodo_payments.refunds.create(payment_id: "payment_id")

            puts(refund)
  /refunds/{refund_id}:
    get:
      tags:
        - Refunds
      operationId: get_refund_handler
      parameters:
        - name: refund_id
          in: path
          description: Refund Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RefundResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const refund = await client.refunds.retrieve('refund_id');

            console.log(refund.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            refund = client.refunds.retrieve(
                "refund_id",
            )
            print(refund.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              refund, err := client.Refunds.Get(context.TODO(), "refund_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", refund.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.refunds.Refund;
            import com.dodopayments.api.models.refunds.RefundRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Refund refund = client.refunds().retrieve("refund_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.refunds.Refund
            import com.dodopayments.api.models.refunds.RefundRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val refund: Refund = client.refunds().retrieve("refund_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            refund = dodo_payments.refunds.retrieve("refund_id")

            puts(refund)
  /subscriptions:
    get:
      tags:
        - Subscriptions
      operationId: list_subscriptions_handler
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: customer_id
          in: query
          description: Filter by customer id
          required: false
          schema:
            type: string
          style: form
        - name: status
          in: query
          description: Filter by status
          required: false
          schema:
            type: string
            enum:
              - pending
              - active
              - on_hold
              - cancelled
              - failed
              - expired
          style: form
        - name: brand_id
          in: query
          description: filter by Brand id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetSubscriptionsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const subscriptionListResponse of client.subscriptions.list()) {
              console.log(subscriptionListResponse.product_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.subscriptions.list()
            page = page.items[0]
            print(page.product_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Subscriptions.List(context.TODO(), dodopayments.SubscriptionListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.subscriptions.SubscriptionListPage;
            import com.dodopayments.api.models.subscriptions.SubscriptionListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    SubscriptionListPage page = client.subscriptions().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.subscriptions.SubscriptionListPage
            import com.dodopayments.api.models.subscriptions.SubscriptionListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: SubscriptionListPage = client.subscriptions().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.subscriptions.list

            puts(page)
    post:
      tags:
        - Subscriptions
      operationId: create_subscription_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateSubscriptionRequest'
        required: true
      responses:
        '200':
          description: Subscription successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateSubscriptionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const subscription = await client.subscriptions.create({
              billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 'zipcode' },
              customer: { customer_id: 'customer_id' },
              product_id: 'product_id',
              quantity: 0,
            });

            console.log(subscription.payment_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            subscription = client.subscriptions.create(
                billing={
                    "city": "city",
                    "country": "AF",
                    "state": "state",
                    "street": "street",
                    "zipcode": "zipcode",
                },
                customer={
                    "customer_id": "customer_id"
                },
                product_id="product_id",
                quantity=0,
            )
            print(subscription.payment_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              subscription, err := client.Subscriptions.New(context.TODO(), dodopayments.SubscriptionNewParams{
                Billing: dodopayments.F(dodopayments.BillingAddressParam{
                  City: dodopayments.F("city"),
                  Country: dodopayments.F(dodopayments.CountryCodeAf),
                  State: dodopayments.F("state"),
                  Street: dodopayments.F("street"),
                  Zipcode: dodopayments.F("zipcode"),
                }),
                Customer: dodopayments.F[dodopayments.CustomerRequestUnionParam](dodopayments.AttachExistingCustomerParam{
                  CustomerID: dodopayments.F("customer_id"),
                }),
                ProductID: dodopayments.F("product_id"),
                Quantity: dodopayments.F(int64(0)),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", subscription.PaymentID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.misc.CountryCode;
            import com.dodopayments.api.models.payments.AttachExistingCustomer;
            import com.dodopayments.api.models.payments.BillingAddress;
            import com.dodopayments.api.models.subscriptions.SubscriptionCreateParams;
            import com.dodopayments.api.models.subscriptions.SubscriptionCreateResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    SubscriptionCreateParams params = SubscriptionCreateParams.builder()
                        .billing(BillingAddress.builder()
                            .city("city")
                            .country(CountryCode.AF)
                            .state("state")
                            .street("street")
                            .zipcode("zipcode")
                            .build())
                        .customer(AttachExistingCustomer.builder()
                            .customerId("customer_id")
                            .build())
                        .productId("product_id")
                        .quantity(0)
                        .build();
                    SubscriptionCreateResponse subscription = client.subscriptions().create(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.misc.CountryCode
            import com.dodopayments.api.models.payments.AttachExistingCustomer
            import com.dodopayments.api.models.payments.BillingAddress
            import com.dodopayments.api.models.subscriptions.SubscriptionCreateParams
            import com.dodopayments.api.models.subscriptions.SubscriptionCreateResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: SubscriptionCreateParams = SubscriptionCreateParams.builder()
                    .billing(BillingAddress.builder()
                        .city("city")
                        .country(CountryCode.AF)
                        .state("state")
                        .street("street")
                        .zipcode("zipcode")
                        .build())
                    .customer(AttachExistingCustomer.builder()
                        .customerId("customer_id")
                        .build())
                    .productId("product_id")
                    .quantity(0)
                    .build()
                val subscription: SubscriptionCreateResponse = client.subscriptions().create(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            subscription = dodo_payments.subscriptions.create(
              billing: {city: "city", country: :AF, state: "state", street: "street", zipcode: "zipcode"},
              customer: {customer_id: "customer_id"},
              product_id: "product_id",
              quantity: 0
            )

            puts(subscription)
  /subscriptions/{subscription_id}:
    get:
      tags:
        - Subscriptions
      operationId: get_subscription_handler
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubscriptionResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const subscription = await client.subscriptions.retrieve('subscription_id');

            console.log(subscription.product_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            subscription = client.subscriptions.retrieve(
                "subscription_id",
            )
            print(subscription.product_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              subscription, err := client.Subscriptions.Get(context.TODO(), "subscription_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", subscription.ProductID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.subscriptions.Subscription;
            import com.dodopayments.api.models.subscriptions.SubscriptionRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Subscription subscription = client.subscriptions().retrieve("subscription_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.subscriptions.Subscription
            import com.dodopayments.api.models.subscriptions.SubscriptionRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val subscription: Subscription = client.subscriptions().retrieve("subscription_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            subscription = dodo_payments.subscriptions.retrieve("subscription_id")

            puts(subscription)
    patch:
      tags:
        - Subscriptions
      operationId: patch_subscription_handler
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchSubscriptionRequest'
        required: true
      responses:
        '200':
          description: Subscription successfully updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubscriptionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const subscription = await client.subscriptions.update('subscription_id');

            console.log(subscription.product_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            subscription = client.subscriptions.update(
                subscription_id="subscription_id",
            )
            print(subscription.product_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              subscription, err := client.Subscriptions.Update(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", subscription.ProductID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.subscriptions.Subscription;
            import com.dodopayments.api.models.subscriptions.SubscriptionUpdateParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    Subscription subscription = client.subscriptions().update("subscription_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.subscriptions.Subscription
            import com.dodopayments.api.models.subscriptions.SubscriptionUpdateParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val subscription: Subscription = client.subscriptions().update("subscription_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            subscription = dodo_payments.subscriptions.update("subscription_id")

            puts(subscription)
  /subscriptions/{subscription_id}/change-plan:
    post:
      tags:
        - Subscriptions
      operationId: update_subscription_plan_handler
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateSubscriptionPlanReq'
        required: true
      responses:
        '200':
          description: Subscription plan changed
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.subscriptions.changePlan('subscription_id', {
              product_id: 'product_id',
              proration_billing_mode: 'prorated_immediately',
              quantity: 0,
            });
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.subscriptions.change_plan(
                subscription_id="subscription_id",
                product_id="product_id",
                proration_billing_mode="prorated_immediately",
                quantity=0,
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Subscriptions.ChangePlan(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionChangePlanParams{
                  ProductID: dodopayments.F("product_id"),
                  ProrationBillingMode: dodopayments.F(dodopayments.SubscriptionChangePlanParamsProrationBillingModeProratedImmediately),
                  Quantity: dodopayments.F(int64(0)),
                },
              )
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.subscriptions.SubscriptionChangePlanParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    SubscriptionChangePlanParams params = SubscriptionChangePlanParams.builder()
                        .subscriptionId("subscription_id")
                        .productId("product_id")
                        .prorationBillingMode(SubscriptionChangePlanParams.ProrationBillingMode.PRORATED_IMMEDIATELY)
                        .quantity(0)
                        .build();
                    client.subscriptions().changePlan(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.subscriptions.SubscriptionChangePlanParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: SubscriptionChangePlanParams = SubscriptionChangePlanParams.builder()
                    .subscriptionId("subscription_id")
                    .productId("product_id")
                    .prorationBillingMode(SubscriptionChangePlanParams.ProrationBillingMode.PRORATED_IMMEDIATELY)
                    .quantity(0)
                    .build()
                client.subscriptions().changePlan(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.subscriptions.change_plan(
              "subscription_id",
              product_id: "product_id",
              proration_billing_mode: :prorated_immediately,
              quantity: 0
            )

            puts(result)
  /subscriptions/{subscription_id}/charge:
    post:
      tags:
        - Subscriptions
      operationId: create_subscription_charge
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateSubscriptionChargeRequest'
        required: true
      responses:
        '200':
          description: Subscription Charge successfully created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateSubscriptionChargeResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.subscriptions.charge('subscription_id', { product_price: 0 });

            console.log(response.payment_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.subscriptions.charge(
                subscription_id="subscription_id",
                product_price=0,
            )
            print(response.payment_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Subscriptions.Charge(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionChargeParams{
                  ProductPrice: dodopayments.F(int64(0)),
                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.PaymentID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.subscriptions.SubscriptionChargeParams;
            import com.dodopayments.api.models.subscriptions.SubscriptionChargeResponse;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    SubscriptionChargeParams params = SubscriptionChargeParams.builder()
                        .subscriptionId("subscription_id")
                        .productPrice(0)
                        .build();
                    SubscriptionChargeResponse response = client.subscriptions().charge(params);
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.subscriptions.SubscriptionChargeParams
            import com.dodopayments.api.models.subscriptions.SubscriptionChargeResponse

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val params: SubscriptionChargeParams = SubscriptionChargeParams.builder()
                    .subscriptionId("subscription_id")
                    .productPrice(0)
                    .build()
                val response: SubscriptionChargeResponse = client.subscriptions().charge(params)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.subscriptions.charge("subscription_id", product_price: 0)

            puts(response)
  /webhook_events:
    get:
      tags:
        - Webhook Events
      operationId: list_webhook_events
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: limit
          in: query
          description: 'Min : 1, Max : 100, default 10'
          required: false
          schema:
            type: integer
            format: int64
          style: form
        - name: object_id
          in: query
          description: Get events history of a specific object like payment/subscription/refund/dispute
          required: false
          schema:
            type: string
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: webhook_id
          in: query
          description: Filter by webhook destination
          required: false
          schema:
            type: string
          style: form
        - name: webhook_event_id
          in: query
          description: Filter by webhook event id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListWebhookEventsResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const webhookEvent of client.webhookEvents.list()) {
              console.log(webhookEvent.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.webhook_events.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.WebhookEvents.List(context.TODO(), dodopayments.WebhookEventListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.webhookevents.WebhookEventListPage;
            import com.dodopayments.api.models.webhookevents.WebhookEventListParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    WebhookEventListPage page = client.webhookEvents().list();
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.webhookevents.WebhookEventListPage
            import com.dodopayments.api.models.webhookevents.WebhookEventListParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val page: WebhookEventListPage = client.webhookEvents().list()
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.webhook_events.list

            puts(page)
  /webhook_events/{webhook_event_id}:
    get:
      tags:
        - Webhook Events
      operationId: get_webhook_event
      parameters:
        - name: webhook_event_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WebhookEventLogResponse'
        '500':
          description: Something went wrong :(
      deprecated: true
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const webhookEvent = await client.webhookEvents.retrieve('webhook_event_id');

            console.log(webhookEvent.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            webhook_event = client.webhook_events.retrieve(
                "webhook_event_id",
            )
            print(webhook_event.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              webhookEvent, err := client.WebhookEvents.Get(context.TODO(), "webhook_event_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", webhookEvent.BusinessID)
            }
        - lang: Java
          source: |-
            package com.dodopayments.api.example;

            import com.dodopayments.api.client.DodoPaymentsClient;
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
            import com.dodopayments.api.models.webhookevents.WebhookEvent;
            import com.dodopayments.api.models.webhookevents.WebhookEventRetrieveParams;

            public final class Main {
                private Main() {}

                public static void main(String[] args) {
                    DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

                    WebhookEvent webhookEvent = client.webhookEvents().retrieve("webhook_event_id");
                }
            }
        - lang: Kotlin
          source: |-
            package com.dodopayments.api.example

            import com.dodopayments.api.client.DodoPaymentsClient
            import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
            import com.dodopayments.api.models.webhookevents.WebhookEvent
            import com.dodopayments.api.models.webhookevents.WebhookEventRetrieveParams

            fun main() {
                val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

                val webhookEvent: WebhookEvent = client.webhookEvents().retrieve("webhook_event_id")
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            webhook_event = dodo_payments.webhook_events.retrieve("webhook_event_id")

            puts(webhook_event)
  /your-webhook-url:
    post:
      tags:
        - Outgoing Webhooks
      operationId: dummy_handler_for_outgoing_webhook_docs
      parameters:
        - name: webhook-id
          in: header
          description: Unique identifier for the webhook
          required: true
          schema:
            type: string
        - name: webhook-signature
          in: header
          description: Signature of the Webhook
          required: true
          schema:
            type: string
        - name: webhook-timestamp
          in: header
          description: Unix timestamp when the webhook was sent
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OutgoingWebhook'
        required: true
      responses:
        '200':
          description: Webhook processed successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
components:
  schemas:
    ActivateLicenseKeyRequest:
      type: object
      required:
        - name
        - license_key
      properties:
        license_key:
          type: string
        name:
          type: string
    AddonCartResponseItem:
      type: object
      description: Response struct representing subscription details
      required:
        - addon_id
        - quantity
      properties:
        addon_id:
          type: string
        quantity:
          type: integer
          format: int32
    AddonResponse:
      type: object
      required:
        - id
        - business_id
        - name
        - tax_category
        - price
        - currency
        - created_at
        - updated_at
      properties:
        business_id:
          type: string
          description: Unique identifier for the business to which the addon belongs.
        created_at:
          type: string
          format: date-time
          description: Created time
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency of the Addon
        description:
          type:
            - string
            - 'null'
          description: Optional description of the Addon
        id:
          type: string
          description: id of the Addon
        image:
          type:
            - string
            - 'null'
          description: Image of the Addon
        name:
          type: string
          description: Name of the Addon
        price:
          type: integer
          format: int32
          description: Amount of the addon
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category applied to this Addon
        updated_at:
          type: string
          format: date-time
          description: Updated time
    AddonsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/AddonResponse'
    AttachAddonReq:
      type: object
      required:
        - addon_id
        - quantity
      properties:
        addon_id:
          type: string
        quantity:
          type: integer
          format: int32
          minimum: 0
    AttachExistingCustomer:
      title: Attach Existing Customer
      type: object
      required:
        - customer_id
      properties:
        customer_id:
          type: string
    BillingAddress:
      type: object
      required:
        - country
        - state
        - city
        - street
        - zipcode
      properties:
        city:
          type: string
          description: City name
        country:
          $ref: '#/components/schemas/CountryCodeAlpha2'
          description: Two-letter ISO country code (ISO 3166-1 alpha-2)
        state:
          type: string
          description: State or province name
        street:
          type: string
          description: Street address including house number and unit/apartment if applicable
        zipcode:
          type: string
          description: Postal code or ZIP code
    BrandResponse:
      type: object
      required:
        - brand_id
        - business_id
        - enabled
        - statement_descriptor
        - verification_status
        - verification_enabled
      properties:
        brand_id:
          type: string
        business_id:
          type: string
        description:
          type:
            - string
            - 'null'
        enabled:
          type: boolean
        image:
          type:
            - string
            - 'null'
        name:
          type:
            - string
            - 'null'
        reason_for_hold:
          type:
            - string
            - 'null'
          description: Incase the brand verification fails or is put on hold
        statement_descriptor:
          type: string
        support_email:
          type:
            - string
            - 'null'
        url:
          type:
            - string
            - 'null'
        verification_enabled:
          type: boolean
        verification_status:
          $ref: '#/components/schemas/BrandVerificationStatus'
    BrandVerificationStatus:
      type: string
      enum:
        - Success
        - Fail
        - Review
        - Hold
    CountryCodeAlpha2:
      type: string
      description: ISO country code alpha2 variant
      enum:
        - AF
        - AX
        - AL
        - DZ
        - AS
        - AD
        - AO
        - AI
        - AQ
        - AG
        - AR
        - AM
        - AW
        - AU
        - AT
        - AZ
        - BS
        - BH
        - BD
        - BB
        - BY
        - BE
        - BZ
        - BJ
        - BM
        - BT
        - BO
        - BQ
        - BA
        - BW
        - BV
        - BR
        - IO
        - BN
        - BG
        - BF
        - BI
        - KH
        - CM
        - CA
        - CV
        - KY
        - CF
        - TD
        - CL
        - CN
        - CX
        - CC
        - CO
        - KM
        - CG
        - CD
        - CK
        - CR
        - CI
        - HR
        - CU
        - CW
        - CY
        - CZ
        - DK
        - DJ
        - DM
        - DO
        - EC
        - EG
        - SV
        - GQ
        - ER
        - EE
        - ET
        - FK
        - FO
        - FJ
        - FI
        - FR
        - GF
        - PF
        - TF
        - GA
        - GM
        - GE
        - DE
        - GH
        - GI
        - GR
        - GL
        - GD
        - GP
        - GU
        - GT
        - GG
        - GN
        - GW
        - GY
        - HT
        - HM
        - VA
        - HN
        - HK
        - HU
        - IS
        - IN
        - ID
        - IR
        - IQ
        - IE
        - IM
        - IL
        - IT
        - JM
        - JP
        - JE
        - JO
        - KZ
        - KE
        - KI
        - KP
        - KR
        - KW
        - KG
        - LA
        - LV
        - LB
        - LS
        - LR
        - LY
        - LI
        - LT
        - LU
        - MO
        - MK
        - MG
        - MW
        - MY
        - MV
        - ML
        - MT
        - MH
        - MQ
        - MR
        - MU
        - YT
        - MX
        - FM
        - MD
        - MC
        - MN
        - ME
        - MS
        - MA
        - MZ
        - MM
        - NA
        - NR
        - NP
        - NL
        - NC
        - NZ
        - NI
        - NE
        - NG
        - NU
        - NF
        - MP
        - 'NO'
        - OM
        - PK
        - PW
        - PS
        - PA
        - PG
        - PY
        - PE
        - PH
        - PN
        - PL
        - PT
        - PR
        - QA
        - RE
        - RO
        - RU
        - RW
        - BL
        - SH
        - KN
        - LC
        - MF
        - PM
        - VC
        - WS
        - SM
        - ST
        - SA
        - SN
        - RS
        - SC
        - SL
        - SG
        - SX
        - SK
        - SI
        - SB
        - SO
        - ZA
        - GS
        - SS
        - ES
        - LK
        - SD
        - SR
        - SJ
        - SZ
        - SE
        - CH
        - SY
        - TW
        - TJ
        - TZ
        - TH
        - TL
        - TG
        - TK
        - TO
        - TT
        - TN
        - TR
        - TM
        - TC
        - TV
        - UG
        - UA
        - AE
        - GB
        - UM
        - US
        - UY
        - UZ
        - VU
        - VE
        - VN
        - VG
        - VI
        - WF
        - EH
        - YE
        - ZM
        - ZW
    CreateAddonRequest:
      type: object
      required:
        - name
        - tax_category
        - price
        - currency
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency of the Addon
        description:
          type:
            - string
            - 'null'
          description: Optional description of the Addon
        name:
          type: string
          description: Name of the Addon
        price:
          type: integer
          format: int32
          description: Amount of the addon
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category applied to this Addon
    CreateBrandRequest:
      type: object
      properties:
        description:
          type:
            - string
            - 'null'
        name:
          type:
            - string
            - 'null'
        statement_descriptor:
          type:
            - string
            - 'null'
        support_email:
          type:
            - string
            - 'null'
        url:
          type:
            - string
            - 'null'
    CreateCustomerPortalSessionResponse:
      type: object
      required:
        - link
      properties:
        link:
          type: string
    CreateCustomerRequest:
      type: object
      required:
        - name
        - email
      properties:
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    CreateDigitalProductDeliveryRequest:
      type: object
      properties:
        external_url:
          type:
            - string
            - 'null'
          description: External URL to digital product
        instructions:
          type:
            - string
            - 'null'
          description: Instructions to download and use the digital product
    CreateDiscountRequest:
      type: object
      description: |-
        Request body for creating a discount.

        `code` is optional; if not provided, we generate a random 16-char code.
      required:
        - type
        - amount
      properties:
        amount:
          type: integer
          format: int32
          description: >-
            The discount amount.


            - If `discount_type` is **not** `percentage`, `amount` is in **USD cents**. For example, `100`
            means `$1.00`.
              Only USD is allowed.
            - If `discount_type` **is** `percentage`, `amount` is in **basis points**. For example, `540`
            means `5.4%`.


            Must be at least 1.
        code:
          type:
            - string
            - 'null'
          description: |-
            Optionally supply a code (will be uppercased).
            - Must be at least 3 characters if provided.
            - If omitted, a random 16-character code is generated.
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: When the discount expires, if ever.
        name:
          type:
            - string
            - 'null'
        restricted_to:
          type:
            - array
            - 'null'
          items:
            type: string
          description: List of product IDs to restrict usage (if any).
        type:
          $ref: '#/components/schemas/DiscountType'
          description: The discount type (e.g. `percentage`, `flat`, or `flat_per_unit`).
        usage_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            How many times this discount can be used (if any).
            Must be >= 1 if provided.
    CreateNewCustomer:
      title: Create New Customer
      type: object
      required:
        - name
        - email
      properties:
        create_new_customer:
          type: boolean
          description: |-
            When false, the most recently created customer object with the given email is used if exists.
            When true, a new customer object is always created
            False by default
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    CreateOneTimePaymentRequest:
      type: object
      required:
        - product_cart
        - customer
        - billing
      properties:
        allowed_payment_method_types:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PaymentMethodTypes'
          description: |-
            List of payment methods allowed during checkout.

            Customers will **never** see payment methods that are **not** in this list.
            However, adding a method here **does not guarantee** customers will see it.
            Availability still depends on other factors (e.g., customer location, merchant settings).
          uniqueItems: true
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for the payment
        billing_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: |-
                Fix the currency in which the end customer is billed.
                If Dodo Payments cannot support that currency for this transaction, it will not proceed
        customer:
          $ref: '#/components/schemas/CustomerRequest'
          description: Customer information for the payment
        discount_code:
          type:
            - string
            - 'null'
          description: Discount Code to apply to the transaction
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: |-
            Additional metadata associated with the payment.
            Defaults to empty if not provided.
        payment_link:
          type:
            - boolean
            - 'null'
          description: Whether to generate a payment link. Defaults to false if not specified.
        product_cart:
          type: array
          items:
            $ref: '#/components/schemas/OneTimeProductCartItemReq'
          description: List of products in the cart. Must contain at least 1 and at most 100 items.
        return_url:
          type:
            - string
            - 'null'
          description: |-
            Optional URL to redirect the customer after payment.
            Must be a valid URL if provided.
        show_saved_payment_methods:
          type: boolean
          description: |-
            Display saved payment methods of a returning customer
            False by default
        tax_id:
          type:
            - string
            - 'null'
          description: Tax ID in case the payment is B2B. If tax id validation fails the payment creation will fail
    CreateOneTimePaymentResponse:
      type: object
      required:
        - payment_id
        - total_amount
        - client_secret
        - customer
        - metadata
      properties:
        client_secret:
          type: string
          description: |-
            Client secret used to load Dodo checkout SDK
            NOTE : Dodo checkout SDK will be coming soon
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Limited details about the customer making the payment
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        expires_on:
          type:
            - string
            - 'null'
          format: date-time
          description: Expiry timestamp of the payment link
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional metadata associated with the payment
        payment_id:
          type: string
          description: Unique identifier for the payment
        payment_link:
          type:
            - string
            - 'null'
          description: Optional URL to a hosted payment page
        product_cart:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/OneTimeProductCartItemReq'
          description: Optional list of products included in the payment
        total_amount:
          type: integer
          format: int32
          description: Total amount of the payment in smallest currency unit (e.g. cents)
          minimum: 0
    CreateProductRequest:
      type: object
      required:
        - tax_category
        - price
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            type: string
          description: Addons available for subscription product
        brand_id:
          type:
            - string
            - 'null'
          description: Brand id for the product, if not provided will default to primary brand
        description:
          type:
            - string
            - 'null'
          description: Optional description of the product
        digital_product_delivery:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/CreateDigitalProductDeliveryRequest'
              description: Choose how you would like you digital product delivered
        license_key_activation_message:
          type:
            - string
            - 'null'
          description: Optional message displayed during license key activation
        license_key_activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            The number of times the license key can be activated.
            Must be 0 or greater
        license_key_duration:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/LicenseKeyDuration'
              description: |-
                Duration configuration for the license key.
                Set to null if you don't want the license key to expire.
                For subscriptions, the lifetime of the license key is tied to the subscription period
        license_key_enabled:
          type:
            - boolean
            - 'null'
          description: |-
            When true, generates and sends a license key to your customer.
            Defaults to false
        name:
          type:
            - string
            - 'null'
          description: Optional name of the product
        price:
          $ref: '#/components/schemas/Price'
          description: Price configuration for the product
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category applied to this product
    CreateRefundRequest:
      type: object
      required:
        - payment_id
      properties:
        items:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PartialRefundItem'
          description: Partially Refund an Individual Item
        payment_id:
          type: string
          description: The unique identifier of the payment to be refunded.
        reason:
          type:
            - string
            - 'null'
          description: The reason for the refund, if any. Maximum length is 3000 characters. Optional.
    CreateSubscriptionChargeRequest:
      type: object
      required:
        - product_price
      properties:
        adaptive_currency_fees_inclusive:
          type:
            - boolean
            - 'null'
          description: >-
            Whether adaptive currency fees should be included in the product_price (true) or added on top
            (false).

            This field is ignored if adaptive pricing is not enabled for the business.
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Metadata'
              description: Metadata for the payment. If not passed, the metadata of the subscription will be taken
        product_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: >-
                Optional currency of the product price. If not specified, defaults to the currency of the
                product.
        product_description:
          type:
            - string
            - 'null'
          description: |-
            Optional product description override for billing and line items.
            If not specified, the stored description of the product will be used.
        product_price:
          type: integer
          format: int32
          description: |-
            The product price. Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
    CreateSubscriptionChargeResponse:
      type: object
      required:
        - payment_id
      properties:
        payment_id:
          type: string
    CreateSubscriptionRequest:
      type: object
      description: |-
        Request payload for creating a new subscription

        This struct represents the data required to create a new subscription in the system.
        It includes details about the product, quantity, customer information, and billing details.
      required:
        - product_id
        - quantity
        - customer
        - billing
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/AttachAddonReq'
          description: Attach addons to this subscription
        allowed_payment_method_types:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PaymentMethodTypes'
          description: |-
            List of payment methods allowed during checkout.

            Customers will **never** see payment methods that are **not** in this list.
            However, adding a method here **does not guarantee** customers will see it.
            Availability still depends on other factors (e.g., customer location, merchant settings).
          uniqueItems: true
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address information for the subscription
        billing_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: |-
                Fix the currency in which the end customer is billed.
                If Dodo Payments cannot support that currency for this transaction, it will not proceed
        customer:
          $ref: '#/components/schemas/CustomerRequest'
          description: Customer details for the subscription
        discount_code:
          type:
            - string
            - 'null'
          description: Discount Code to apply to the subscription
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: |-
            Additional metadata for the subscription
            Defaults to empty if not specified
        on_demand:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/OnDemandSubscriptionReq'
        payment_link:
          type:
            - boolean
            - 'null'
          description: |-
            If true, generates a payment link.
            Defaults to false if not specified.
        product_id:
          type: string
          description: Unique identifier of the product to subscribe to
        quantity:
          type: integer
          format: int32
          description: Number of units to subscribe for. Must be at least 1.
          minimum: 0
        return_url:
          type:
            - string
            - 'null'
          description: Optional URL to redirect after successful subscription creation
        show_saved_payment_methods:
          type: boolean
          description: |-
            Display saved payment methods of a returning customer
            False by default
        tax_id:
          type:
            - string
            - 'null'
          description: Tax ID in case the payment is B2B. If tax id validation fails the payment creation will fail
        trial_period_days:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Optional trial period in days
            If specified, this value overrides the trial period set in the product's price
            Must be between 0 and 10000 days
    CreateSubscriptionResponse:
      type: object
      required:
        - subscription_id
        - recurring_pre_tax_amount
        - customer
        - metadata
        - addons
        - payment_id
      properties:
        addons:
          type: array
          items:
            $ref: '#/components/schemas/AddonCartResponseItem'
          description: Addons associated with this subscription
        client_secret:
          type:
            - string
            - 'null'
          description: |-
            Client secret used to load Dodo checkout SDK
            NOTE : Dodo checkout SDK will be coming soon
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Customer details associated with this subscription
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        expires_on:
          type:
            - string
            - 'null'
          format: date-time
          description: Expiry timestamp of the payment link
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional metadata associated with the subscription
        payment_id:
          type: string
          description: First payment id for the subscription
        payment_link:
          type:
            - string
            - 'null'
          description: URL to checkout page
        recurring_pre_tax_amount:
          type: integer
          format: int32
          description: Tax will be added to the amount and charged to the customer on each billing cycle
          minimum: 0
        subscription_id:
          type: string
          description: Unique identifier for the subscription
    Currency:
      type: string
      enum:
        - AED
        - ALL
        - AMD
        - ANG
        - AOA
        - ARS
        - AUD
        - AWG
        - AZN
        - BAM
        - BBD
        - BDT
        - BGN
        - BHD
        - BIF
        - BMD
        - BND
        - BOB
        - BRL
        - BSD
        - BWP
        - BYN
        - BZD
        - CAD
        - CHF
        - CLP
        - CNY
        - COP
        - CRC
        - CUP
        - CVE
        - CZK
        - DJF
        - DKK
        - DOP
        - DZD
        - EGP
        - ETB
        - EUR
        - FJD
        - FKP
        - GBP
        - GEL
        - GHS
        - GIP
        - GMD
        - GNF
        - GTQ
        - GYD
        - HKD
        - HNL
        - HRK
        - HTG
        - HUF
        - IDR
        - ILS
        - INR
        - IQD
        - JMD
        - JOD
        - JPY
        - KES
        - KGS
        - KHR
        - KMF
        - KRW
        - KWD
        - KYD
        - KZT
        - LAK
        - LBP
        - LKR
        - LRD
        - LSL
        - LYD
        - MAD
        - MDL
        - MGA
        - MKD
        - MMK
        - MNT
        - MOP
        - MRU
        - MUR
        - MVR
        - MWK
        - MXN
        - MYR
        - MZN
        - NAD
        - NGN
        - NIO
        - NOK
        - NPR
        - NZD
        - OMR
        - PAB
        - PEN
        - PGK
        - PHP
        - PKR
        - PLN
        - PYG
        - QAR
        - RON
        - RSD
        - RUB
        - RWF
        - SAR
        - SBD
        - SCR
        - SEK
        - SGD
        - SHP
        - SLE
        - SLL
        - SOS
        - SRD
        - SSP
        - STN
        - SVC
        - SZL
        - THB
        - TND
        - TOP
        - TRY
        - TTD
        - TWD
        - TZS
        - UAH
        - UGX
        - USD
        - UYU
        - UZS
        - VES
        - VND
        - VUV
        - WST
        - XAF
        - XCD
        - XOF
        - XPF
        - YER
        - ZAR
        - ZMW
    CustomerLimitedDetailsResponse:
      type: object
      required:
        - customer_id
        - name
        - email
      properties:
        customer_id:
          type: string
          description: Unique identifier for the customer
        email:
          type: string
          description: Email address of the customer
        name:
          type: string
          description: Full name of the customer
    CustomerRequest:
      oneOf:
        - $ref: '#/components/schemas/AttachExistingCustomer'
        - $ref: '#/components/schemas/CreateNewCustomer'
    CustomerResponse:
      type: object
      required:
        - customer_id
        - business_id
        - name
        - email
        - created_at
      properties:
        business_id:
          type: string
        created_at:
          type: string
          format: date-time
        customer_id:
          type: string
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    DeactivateLicenseKeyRequest:
      type: object
      required:
        - license_key
        - license_key_instance_id
      properties:
        license_key:
          type: string
        license_key_instance_id:
          type: string
    DigitalProductDelivery:
      type: object
      properties:
        external_url:
          type:
            - string
            - 'null'
          description: External URL to digital product
        files:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/DigitalProductDeliveryFile'
          description: Uploaded files ids of digital product
        instructions:
          type:
            - string
            - 'null'
          description: Instructions to download and use the digital product
    DigitalProductDeliveryFile:
      type: object
      required:
        - file_id
        - file_name
        - url
      properties:
        file_id:
          type: string
          format: uuid
        file_name:
          type: string
        url:
          type: string
    DisableOnDemandReq:
      type: object
      required:
        - next_billing_date
      properties:
        next_billing_date:
          type: string
          format: date-time
    DiscountResponse:
      type: object
      required:
        - discount_id
        - business_id
        - type
        - code
        - amount
        - times_used
        - restricted_to
        - created_at
      properties:
        amount:
          type: integer
          format: int32
          description: |-
            The discount amount.

            - If `discount_type` is `percentage`, this is in **basis points**
              (e.g., 540 => 5.4%).
            - Otherwise, this is **USD cents** (e.g., 100 => `$1.00`).
        business_id:
          type: string
          description: The business this discount belongs to.
        code:
          type: string
          description: The discount code (up to 16 chars).
        created_at:
          type: string
          format: date-time
          description: Timestamp when the discount is created
        discount_id:
          type: string
          description: The unique discount ID
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Optional date/time after which discount is expired.
        name:
          type:
            - string
            - 'null'
          description: Name for the Discount
        restricted_to:
          type: array
          items:
            type: string
          description: List of product IDs to which this discount is restricted.
        times_used:
          type: integer
          format: int32
          description: How many times this discount has been used.
        type:
          $ref: '#/components/schemas/DiscountType'
          description: The type of discount, e.g. `percentage`, `flat`, or `flat_per_unit`.
        usage_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: Usage limit for this discount, if any.
    DiscountType:
      type: string
      enum:
        - percentage
    DisputeResponse:
      type: object
      required:
        - dispute_id
        - payment_id
        - business_id
        - amount
        - currency
        - dispute_status
        - dispute_stage
        - created_at
      properties:
        amount:
          type: string
          description: The amount involved in the dispute, represented as a string to accommodate precision.
        business_id:
          type: string
          description: The unique identifier of the business involved in the dispute.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the dispute was created, in UTC.
        currency:
          type: string
          description: The currency of the disputed amount, represented as an ISO 4217 currency code.
        dispute_id:
          type: string
          description: The unique identifier of the dispute.
        dispute_stage:
          $ref: '#/components/schemas/DisputeStage'
          description: The current stage of the dispute process.
        dispute_status:
          $ref: '#/components/schemas/DisputeStatus'
          description: The current status of the dispute.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the dispute.
        remarks:
          type:
            - string
            - 'null'
          description: Remarks
    DisputeStage:
      type: string
      enum:
        - pre_dispute
        - dispute
        - pre_arbitration
    DisputeStatus:
      type: string
      enum:
        - dispute_opened
        - dispute_expired
        - dispute_accepted
        - dispute_cancelled
        - dispute_challenged
        - dispute_won
        - dispute_lost
    EventType:
      type: string
      description: Event types for Dodo events
      enum:
        - payment.succeeded
        - payment.failed
        - payment.processing
        - payment.cancelled
        - refund.succeeded
        - refund.failed
        - dispute.opened
        - dispute.expired
        - dispute.accepted
        - dispute.cancelled
        - dispute.challenged
        - dispute.won
        - dispute.lost
        - subscription.active
        - subscription.renewed
        - subscription.on_hold
        - subscription.paused
        - subscription.cancelled
        - subscription.failed
        - subscription.expired
        - subscription.plan_changed
        - license_key.created
    GetCustomersListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/CustomerResponse'
    GetDiscountsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/DiscountResponse'
          description: Array of active (non-deleted) discounts for the current page.
    GetDisputeResponse:
      type: object
      required:
        - dispute_id
        - payment_id
        - business_id
        - amount
        - currency
        - dispute_status
        - dispute_stage
        - created_at
        - customer
      properties:
        amount:
          type: string
          description: The amount involved in the dispute, represented as a string to accommodate precision.
        business_id:
          type: string
          description: The unique identifier of the business involved in the dispute.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the dispute was created, in UTC.
        currency:
          type: string
          description: The currency of the disputed amount, represented as an ISO 4217 currency code.
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: The customer who filed the dispute
        dispute_id:
          type: string
          description: The unique identifier of the dispute.
        dispute_stage:
          $ref: '#/components/schemas/DisputeStage'
          description: The current stage of the dispute process.
        dispute_status:
          $ref: '#/components/schemas/DisputeStatus'
          description: The current status of the dispute.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the dispute.
        reason:
          type:
            - string
            - 'null'
          description: Reason for the dispute
        remarks:
          type:
            - string
            - 'null'
          description: Remarks
    GetDisputesListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/ListDisputeResponse'
    GetPaymentsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/GetPaymentsListResponseItem'
    GetPaymentsListResponseItem:
      type: object
      required:
        - payment_id
        - total_amount
        - currency
        - customer
        - created_at
        - brand_id
        - digital_products_delivered
        - metadata
      properties:
        brand_id:
          type: string
        created_at:
          type: string
          format: date-time
        currency:
          $ref: '#/components/schemas/Currency'
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
        digital_products_delivered:
          type: boolean
        metadata:
          $ref: '#/components/schemas/Metadata'
        payment_id:
          type: string
        payment_method:
          type:
            - string
            - 'null'
        payment_method_type:
          type:
            - string
            - 'null'
        status:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/IntentStatus'
        subscription_id:
          type:
            - string
            - 'null'
        total_amount:
          type: integer
          format: int32
    GetPayoutsResponseList:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutsResponse'
    GetProductResponse:
      type: object
      required:
        - product_id
        - business_id
        - created_at
        - updated_at
        - is_recurring
        - tax_category
        - price
        - license_key_enabled
        - brand_id
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            type: string
          description: Available Addons for subscription products
        brand_id:
          type: string
        business_id:
          type: string
          description: Unique identifier for the business to which the product belongs.
        created_at:
          type: string
          format: date-time
          description: Timestamp when the product was created.
        description:
          type:
            - string
            - 'null'
          description: Description of the product, optional.
        digital_product_delivery:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/DigitalProductDelivery'
        image:
          type:
            - string
            - 'null'
          description: URL of the product image, optional.
        is_recurring:
          type: boolean
          description: Indicates if the product is recurring (e.g., subscriptions).
        license_key_activation_message:
          type:
            - string
            - 'null'
          description: Message sent upon license key activation, if applicable.
        license_key_activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: Limit on the number of activations for the license key, if enabled.
        license_key_duration:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/LicenseKeyDuration'
              description: Duration of the license key validity, if enabled.
        license_key_enabled:
          type: boolean
          description: Indicates whether the product requires a license key.
        name:
          type:
            - string
            - 'null'
          description: Name of the product, optional.
        price:
          $ref: '#/components/schemas/Price'
          description: Pricing information for the product.
        product_id:
          type: string
          description: Unique identifier for the product.
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category associated with the product.
        updated_at:
          type: string
          format: date-time
          description: Timestamp when the product was last updated.
    GetProductsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/GetProductsListResponseItem'
    GetProductsListResponseItem:
      type: object
      required:
        - product_id
        - business_id
        - created_at
        - updated_at
        - is_recurring
        - tax_category
      properties:
        business_id:
          type: string
          description: Unique identifier for the business to which the product belongs.
        created_at:
          type: string
          format: date-time
          description: Timestamp when the product was created.
        currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: Currency of the price
        description:
          type:
            - string
            - 'null'
          description: Description of the product, optional.
        image:
          type:
            - string
            - 'null'
          description: URL of the product image, optional.
        is_recurring:
          type: boolean
          description: Indicates if the product is recurring (e.g., subscriptions).
        name:
          type:
            - string
            - 'null'
          description: Name of the product, optional.
        price:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Price of the product, optional.

            The price is represented in the lowest denomination of the currency.
            For example:
            - In USD, a price of `$12.34` would be represented as `1234` (cents).
            - In JPY, a price of `1500` would be represented as `1500` (yen).
            - In INR, a price of `1234.56` would be represented as `123456` (paise).

            This ensures precision and avoids floating-point rounding errors.
        price_detail:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Price'
              description: Details of the price
        product_id:
          type: string
          description: Unique identifier for the product.
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category associated with the product.
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive
        updated_at:
          type: string
          format: date-time
          description: Timestamp when the product was last updated.
    GetRefundsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/RefundResponse'
    GetSubscriptionsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/SubscriptionListResponseItem'
    IntentStatus:
      type: string
      enum:
        - succeeded
        - failed
        - cancelled
        - processing
        - requires_customer_action
        - requires_merchant_action
        - requires_payment_method
        - requires_confirmation
        - requires_capture
        - partially_captured
        - partially_captured_and_capturable
    LicenseKeyDuration:
      type: object
      required:
        - count
        - interval
      properties:
        count:
          type: integer
          format: int32
        interval:
          $ref: '#/components/schemas/TimeInterval'
    LicenseKeyInstanceResponse:
      type: object
      required:
        - id
        - business_id
        - name
        - license_key_id
        - created_at
      properties:
        business_id:
          type: string
        created_at:
          type: string
          format: date-time
          example: '2024-01-01T00:00:00Z'
        id:
          type: string
          example: lki_123
        license_key_id:
          type: string
          example: lic_123
        name:
          type: string
          example: Production Server 1
    LicenseKeyResponse:
      type: object
      required:
        - id
        - business_id
        - key
        - status
        - customer_id
        - product_id
        - payment_id
        - instances_count
        - created_at
      properties:
        activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: The maximum number of activations allowed for this license key.
          example: 5
        business_id:
          type: string
          description: The unique identifier of the business associated with the license key.
        created_at:
          type: string
          format: date-time
          description: The timestamp indicating when the license key was created, in UTC.
          example: '2024-01-01T00:00:00Z'
        customer_id:
          type: string
          description: The unique identifier of the customer associated with the license key.
          example: cus_123
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: The timestamp indicating when the license key expires, in UTC.
          example: '2024-12-31T23:59:59Z'
        id:
          type: string
          description: The unique identifier of the license key.
          example: lic_123
        instances_count:
          type: integer
          format: int32
          description: The current number of instances activated for this license key.
        key:
          type: string
          description: The license key string.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the license key.
        product_id:
          type: string
          description: The unique identifier of the product associated with the license key.
        status:
          $ref: '#/components/schemas/LicenseKeyStatus'
          description: The current status of the license key (e.g., active, inactive, expired).
        subscription_id:
          type:
            - string
            - 'null'
          description: The unique identifier of the subscription associated with the license key, if any.
    LicenseKeyStatus:
      type: string
      enum:
        - active
        - expired
        - disabled
    ListBrandsResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/BrandResponse'
          description: List of brands for this business
    ListDisputeResponse:
      type: object
      required:
        - dispute_id
        - payment_id
        - business_id
        - amount
        - currency
        - dispute_status
        - dispute_stage
        - created_at
      properties:
        amount:
          type: string
          description: The amount involved in the dispute, represented as a string to accommodate precision.
        business_id:
          type: string
          description: The unique identifier of the business involved in the dispute.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the dispute was created, in UTC.
        currency:
          type: string
          description: The currency of the disputed amount, represented as an ISO 4217 currency code.
        dispute_id:
          type: string
          description: The unique identifier of the dispute.
        dispute_stage:
          $ref: '#/components/schemas/DisputeStage'
          description: The current stage of the dispute process.
        dispute_status:
          $ref: '#/components/schemas/DisputeStatus'
          description: The current status of the dispute.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the dispute.
    ListLicenseKeyInstancesResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/LicenseKeyInstanceResponse'
    ListLicenseKeysResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/LicenseKeyResponse'
    ListWebhookEventsResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/WebhookEventLogResponse'
    Metadata:
      type: object
      additionalProperties:
        type: string
      propertyNames:
        type: string
    OnDemandSubscriptionReq:
      type: object
      required:
        - mandate_only
      properties:
        adaptive_currency_fees_inclusive:
          type:
            - boolean
            - 'null'
          description: >-
            Whether adaptive currency fees should be included in the product_price (true) or added on top
            (false).

            This field is ignored if adaptive pricing is not enabled for the business.
        mandate_only:
          type: boolean
          description: >-
            If set as True, does not perform any charge and only authorizes payment method details for future
            use.
        product_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: >-
                Optional currency of the product price. If not specified, defaults to the currency of the
                product.
        product_description:
          type:
            - string
            - 'null'
          description: |-
            Optional product description override for billing and line items.
            If not specified, the stored description of the product will be used.
        product_price:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Product price for the initial charge to customer
            If not specified the stored price of the product will be used
            Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
    OneTimePrice:
      type: object
      required:
        - price
        - currency
        - discount
        - purchasing_power_parity
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency in which the payment is made.
        discount:
          type: number
          format: float
          description: Discount applied to the price, represented as a percentage (0 to 100).
        pay_what_you_want:
          type: boolean
          description: |-
            Indicates whether the customer can pay any amount they choose.
            If set to `true`, the [`price`](Self::price) field is the minimum amount.
        price:
          type: integer
          format: int32
          description: |-
            The payment amount, in the smallest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.

            If [`pay_what_you_want`](Self::pay_what_you_want) is set to `true`, this field represents
            the **minimum** amount the customer must pay.
        purchasing_power_parity:
          type: boolean
          description: |-
            Indicates if purchasing power parity adjustments are applied to the price.
            Purchasing power parity feature is not available as of now.
        suggested_price:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            A suggested price for the user to pay. This value is only considered if
            [`pay_what_you_want`](Self::pay_what_you_want) is `true`. Otherwise, it is ignored.
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive.
    OneTimeProductCartItemReq:
      type: object
      required:
        - product_id
        - quantity
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Amount the customer pays if pay_what_you_want is enabled. If disabled then amount will be ignored
            Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
        product_id:
          type: string
        quantity:
          type: integer
          format: int32
          minimum: 0
    OneTimeProductCartItemResponse:
      type: object
      required:
        - product_id
        - quantity
      properties:
        product_id:
          type: string
        quantity:
          type: integer
          format: int32
          minimum: 0
    OutgoingWebhook:
      type: object
      required:
        - business_id
        - type
        - timestamp
        - data
      properties:
        business_id:
          type: string
        data:
          $ref: '#/components/schemas/OutgoingWebhookData'
          description: The latest data at the time of delivery attempt
        timestamp:
          type: string
          format: date-time
          description: The timestamp of when the event occurred (not necessarily the same of when it was delivered)
        type:
          $ref: '#/components/schemas/EventType'
    OutgoingWebhookData:
      oneOf:
        - allOf:
            - $ref: '#/components/schemas/PaymentResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Payment
          title: Payment
        - allOf:
            - $ref: '#/components/schemas/SubscriptionResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Subscription
          title: Subscription
        - allOf:
            - $ref: '#/components/schemas/RefundResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Refund
          title: Refund
        - allOf:
            - $ref: '#/components/schemas/GetDisputeResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Dispute
          title: Dispute
        - allOf:
            - $ref: '#/components/schemas/LicenseKeyResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - LicenseKey
          title: License Key
    PartialRefundItem:
      type: object
      required:
        - item_id
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: The amount to refund. if None the whole item is refunded
        item_id:
          type: string
          description: The id of the item (i.e. `product_id` or `addon_id`)
        tax_inclusive:
          type: boolean
          description: Specify if tax is inclusive of the refund. Default true.
    PatchAddonRequest:
      type: object
      properties:
        currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: The currency of the Addon
        description:
          type:
            - string
            - 'null'
          description: Description of the Addon, optional and must be at most 1000 characters.
        image_id:
          type:
            - string
            - 'null'
          format: uuid
          description: Addon image id after its uploaded to S3
        name:
          type:
            - string
            - 'null'
          description: Name of the Addon, optional and must be at most 100 characters.
        price:
          type:
            - integer
            - 'null'
          format: int32
          description: Amount of the addon
        tax_category:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/TaxCategory'
              description: Tax category of the Addon.
    PatchBrandRequest:
      type: object
      properties:
        image_id:
          type:
            - string
            - 'null'
          format: uuid
          description: The UUID you got back from the presignedupload call
        name:
          type:
            - string
            - 'null'
        statement_descriptor:
          type:
            - string
            - 'null'
        support_email:
          type:
            - string
            - 'null'
    PatchCustomerRequest:
      type: object
      properties:
        name:
          type:
            - string
            - 'null'
        phone_number:
          type:
            - string
            - 'null'
    PatchDigitalProductDeliveryRequest:
      type: object
      properties:
        external_url:
          type:
            - string
            - 'null'
          description: External URL to digital product
        files:
          type:
            - array
            - 'null'
          items:
            type: string
            format: uuid
          description: Uploaded files ids of digital product
        instructions:
          type:
            - string
            - 'null'
          description: Instructions to download and use the digital product
    PatchDiscountRequest:
      type: object
      description: |-
        Request body for patching (updating) a discount.

        All fields are optional and only update if provided.
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            If present, update the discount amount:
            - If `discount_type` is `percentage`, this represents **basis points** (e.g., `540` = `5.4%`).
            - Otherwise, this represents **USD cents** (e.g., `100` = `$1.00`).

            Must be at least 1 if provided.
        code:
          type:
            - string
            - 'null'
          description: If present, update the discount code (uppercase).
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
        name:
          type:
            - string
            - 'null'
        restricted_to:
          type:
            - array
            - 'null'
          items:
            type: string
          description: |-
            If present, replaces all restricted product IDs with this new set.
            To remove all restrictions, send empty array
        type:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/DiscountType'
              description: If present, update the discount type.
        usage_limit:
          type:
            - integer
            - 'null'
          format: int32
    PatchLicenseKeyInstanceRequest:
      type: object
      required:
        - name
      properties:
        name:
          type: string
    PatchLicenseKeyRequest:
      type: object
      properties:
        activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            The updated activation limit for the license key.
            Use `null` to remove the limit, or omit this field to leave it unchanged.
        disabled:
          type:
            - boolean
            - 'null'
          description: >-
            Indicates whether the license key should be disabled.

            A value of `true` disables the key, while `false` enables it. Omit this field to leave it
            unchanged.
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: |-
            The updated expiration timestamp for the license key in UTC.
            Use `null` to remove the expiration date, or omit this field to leave it unchanged.
    PatchProductRequest:
      type: object
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            type: string
          description: Available Addons for subscription products
        brand_id:
          type:
            - string
            - 'null'
        description:
          type:
            - string
            - 'null'
          description: Description of the product, optional and must be at most 1000 characters.
        digital_product_delivery:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/PatchDigitalProductDeliveryRequest'
              description: Choose how you would like you digital product delivered
        image_id:
          type:
            - string
            - 'null'
          format: uuid
          description: Product image id after its uploaded to S3
        license_key_activation_message:
          type:
            - string
            - 'null'
          description: |-
            Message sent to the customer upon license key activation.

            Only applicable if `license_key_enabled` is `true`. This message contains instructions for
            activating the license key.
        license_key_activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Limit for the number of activations for the license key.

            Only applicable if `license_key_enabled` is `true`. Represents the maximum number of times
            the license key can be activated.
        license_key_duration:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/LicenseKeyDuration'
              description: |-
                Duration of the license key if enabled.

                Only applicable if `license_key_enabled` is `true`. Represents the duration in days for which
                the license key is valid.
        license_key_enabled:
          type:
            - boolean
            - 'null'
          description: >-
            Whether the product requires a license key.


            If `true`, additional fields related to license key (duration, activations limit, activation
            message)

            become applicable.
        name:
          type:
            - string
            - 'null'
          description: Name of the product, optional and must be at most 100 characters.
        price:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Price'
              description: Price details of the product.
        tax_category:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/TaxCategory'
              description: Tax category of the product.
    PatchSubscriptionRequest:
      type: object
      properties:
        billing:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/BillingAddress'
        cancel_at_next_billing_date:
          type:
            - boolean
            - 'null'
        disable_on_demand:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/DisableOnDemandReq'
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Metadata'
        status:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/SubscriptionStatus'
        tax_id:
          type:
            - string
            - 'null'
    PaymentLineItem:
      type: object
      required:
        - items_id
        - amount
        - tax
        - refundable_amount
      properties:
        amount:
          type: integer
          format: int32
        description:
          type:
            - string
            - 'null'
        items_id:
          type: string
        name:
          type:
            - string
            - 'null'
        refundable_amount:
          type: integer
          format: int32
        tax:
          type: integer
          format: int32
    PaymentLineItemsResponse:
      type: object
      required:
        - currency
        - items
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
        items:
          type: array
          items:
            $ref: '#/components/schemas/PaymentLineItem'
    PaymentMethodTypes:
      type: string
      enum:
        - credit
        - debit
        - upi_collect
        - upi_intent
        - apple_pay
        - cashapp
        - google_pay
        - multibanco
        - bancontact_card
        - eps
        - ideal
        - przelewy24
        - affirm
        - klarna
        - sepa
        - ach
        - amazon_pay
        - afterpay_clearpay
    PaymentResponse:
      type: object
      required:
        - payment_id
        - business_id
        - total_amount
        - currency
        - created_at
        - disputes
        - refunds
        - customer
        - metadata
        - settlement_amount
        - settlement_currency
        - billing
        - brand_id
        - digital_products_delivered
      properties:
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for payments
        brand_id:
          type: string
          description: brand id this payment belongs to
        business_id:
          type: string
          description: Identifier of the business associated with the payment
        card_issuing_country:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/CountryCodeAlpha2'
              description: ISO2 country code of the card
        card_last_four:
          type:
            - string
            - 'null'
          description: The last four digits of the card
        card_network:
          type:
            - string
            - 'null'
          description: Card network like VISA, MASTERCARD etc.
        card_type:
          type:
            - string
            - 'null'
          description: The type of card DEBIT or CREDIT
        created_at:
          type: string
          format: date-time
          description: Timestamp when the payment was created
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency used for the payment
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Details about the customer who made the payment
        digital_products_delivered:
          type: boolean
          description: brand id this payment belongs to
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        disputes:
          type: array
          items:
            $ref: '#/components/schemas/DisputeResponse'
          description: List of disputes associated with this payment
        error_code:
          type:
            - string
            - 'null'
          description: An error code if the payment failed
        error_message:
          type:
            - string
            - 'null'
          description: An error message if the payment failed
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the payment
        payment_id:
          type: string
          description: Unique identifier for the payment
        payment_link:
          type:
            - string
            - 'null'
          description: Checkout URL
        payment_method:
          type:
            - string
            - 'null'
          description: Payment method used by customer (e.g. "card", "bank_transfer")
        payment_method_type:
          type:
            - string
            - 'null'
          description: Specific type of payment method (e.g. "visa", "mastercard")
        product_cart:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/OneTimeProductCartItemResponse'
          description: List of products purchased in a one-time payment
        refunds:
          type: array
          items:
            $ref: '#/components/schemas/RefundResponse'
          description: List of refunds issued for this payment
        settlement_amount:
          type: integer
          format: int32
          description: >-
            The amount that will be credited to your Dodo balance after currency conversion and processing.

            Especially relevant for adaptive pricing where the customer's payment currency differs from your
            settlement currency.
        settlement_currency:
          $ref: '#/components/schemas/Currency'
          description: |-
            The currency in which the settlement_amount will be credited to your Dodo balance.
            This may differ from the customer's payment currency in adaptive pricing scenarios.
        settlement_tax:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            This represents the portion of settlement_amount that corresponds to taxes collected.
            Especially relevant for adaptive pricing where the tax component must be tracked separately
            in your Dodo balance.
        status:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/IntentStatus'
              description: Current status of the payment intent
        subscription_id:
          type:
            - string
            - 'null'
          description: Identifier of the subscription if payment is part of a subscription
        tax:
          type:
            - integer
            - 'null'
          format: int32
          description: Amount of tax collected in smallest currency unit (e.g. cents)
        total_amount:
          type: integer
          format: int32
          description: Total amount charged to the customer including tax, in smallest currency unit (e.g. cents)
        updated_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Timestamp when the payment was last updated
    PayoutStatus:
      type: string
      enum:
        - not_initiated
        - in_progress
        - on_hold
        - failed
        - success
    PayoutsResponse:
      type: object
      required:
        - payout_id
        - business_id
        - payment_method
        - status
        - fee
        - tax
        - amount
        - created_at
        - updated_at
        - currency
        - refunds
        - chargebacks
      properties:
        amount:
          type: integer
          format: int64
          description: The total amount of the payout.
        business_id:
          type: string
          description: The unique identifier of the business associated with the payout.
        chargebacks:
          type: integer
          format: int64
          description: The total value of chargebacks associated with the payout.
        created_at:
          type: string
          format: date-time
          description: The timestamp when the payout was created, in UTC.
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency of the payout, represented as an ISO 4217 currency code.
        fee:
          type: integer
          format: int64
          description: The fee charged for processing the payout.
        name:
          type:
            - string
            - 'null'
          description: The name of the payout recipient or purpose.
        payment_method:
          type: string
          description: The payment method used for the payout (e.g., bank transfer, card, etc.).
        payout_document_url:
          type:
            - string
            - 'null'
          description: The URL of the document associated with the payout.
        payout_id:
          type: string
          description: The unique identifier of the payout.
        refunds:
          type: integer
          format: int64
          description: The total value of refunds associated with the payout.
        remarks:
          type:
            - string
            - 'null'
          description: Any additional remarks or notes associated with the payout.
        status:
          $ref: '#/components/schemas/PayoutStatus'
          description: The current status of the payout.
        tax:
          type: integer
          format: int64
          description: The tax applied to the payout.
        updated_at:
          type: string
          format: date-time
          description: The timestamp when the payout was last updated, in UTC.
    Price:
      oneOf:
        - allOf:
            - $ref: '#/components/schemas/OneTimePrice'
              description: One-time price details.
            - type: object
              required:
                - type
              properties:
                type:
                  type: string
                  enum:
                    - one_time_price
          title: One Time Price
          description: One-time price details.
        - allOf:
            - $ref: '#/components/schemas/RecurringPrice'
              description: Recurring price details.
            - type: object
              required:
                - type
              properties:
                type:
                  type: string
                  enum:
                    - recurring_price
          title: Recurring Price
          description: Recurring price details.
    ProrationBillingMode:
      type: string
      enum:
        - prorated_immediately
        - full_immediately
    RecurringPrice:
      type: object
      required:
        - price
        - currency
        - discount
        - purchasing_power_parity
        - payment_frequency_count
        - payment_frequency_interval
        - subscription_period_count
        - subscription_period_interval
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency in which the payment is made.
        discount:
          type: number
          format: float
          description: Discount applied to the price, represented as a percentage (0 to 100).
        payment_frequency_count:
          type: integer
          format: int32
          description: >-
            Number of units for the payment frequency.

            For example, a value of `1` with a `payment_frequency_interval` of `month` represents monthly
            payments.
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: The time interval for the payment frequency (e.g., day, month, year).
        price:
          type: integer
          format: int32
          description: |-
            The payment amount. Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
        purchasing_power_parity:
          type: boolean
          description: |-
            Indicates if purchasing power parity adjustments are applied to the price.
            Purchasing power parity feature is not available as of now
        subscription_period_count:
          type: integer
          format: int32
          description: >-
            Number of units for the subscription period.

            For example, a value of `12` with a `subscription_period_interval` of `month` represents a
            one-year subscription.
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: The time interval for the subscription period (e.g., day, month, year).
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive
        trial_period_days:
          type: integer
          format: int32
          description: Number of days for the trial period. A value of `0` indicates no trial period.
    RefundResponse:
      type: object
      required:
        - refund_id
        - payment_id
        - business_id
        - status
        - created_at
        - is_partial
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: The refunded amount.
        business_id:
          type: string
          description: The unique identifier of the business issuing the refund.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the refund was created in UTC.
        currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: The currency of the refund, represented as an ISO 4217 currency code.
        is_partial:
          type: boolean
          description: If true the refund is a partial refund
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the refund.
        reason:
          type:
            - string
            - 'null'
          description: The reason provided for the refund, if any. Optional.
        refund_id:
          type: string
          description: The unique identifier of the refund.
        status:
          $ref: '#/components/schemas/RefundStatus'
          description: The current status of the refund.
    RefundStatus:
      type: string
      enum:
        - succeeded
        - failed
        - pending
        - review
    SubscriptionListResponseItem:
      type: object
      description: Response struct representing subscription details
      required:
        - subscription_id
        - recurring_pre_tax_amount
        - tax_inclusive
        - currency
        - status
        - created_at
        - product_id
        - quantity
        - trial_period_days
        - subscription_period_interval
        - payment_frequency_interval
        - subscription_period_count
        - payment_frequency_count
        - next_billing_date
        - previous_billing_date
        - customer
        - metadata
        - cancel_at_next_billing_date
        - billing
        - on_demand
      properties:
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for payments
        cancel_at_next_billing_date:
          type: boolean
          description: Indicates if the subscription will cancel at the next billing date
        cancelled_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Cancelled timestamp if the subscription is cancelled
        created_at:
          type: string
          format: date-time
          description: Timestamp when the subscription was created
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency used for the subscription payments
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Customer details associated with the subscription
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the subscription
        next_billing_date:
          type: string
          format: date-time
          description: Timestamp of the next scheduled billing. Indicates the end of current billing period
        on_demand:
          type: boolean
          description: Wether the subscription is on-demand or not
        payment_frequency_count:
          type: integer
          format: int32
          description: Number of payment frequency intervals
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for payment frequency (e.g. month, year)
        previous_billing_date:
          type: string
          format: date-time
          description: Timestamp of the last payment. Indicates the start of current billing period
        product_id:
          type: string
          description: Identifier of the product associated with this subscription
        quantity:
          type: integer
          format: int32
          description: Number of units/items included in the subscription
        recurring_pre_tax_amount:
          type: integer
          format: int32
          description: Amount charged before tax for each recurring payment in smallest currency unit (e.g. cents)
        status:
          $ref: '#/components/schemas/SubscriptionStatus'
          description: Current status of the subscription
        subscription_id:
          type: string
          description: Unique identifier for the subscription
        subscription_period_count:
          type: integer
          format: int32
          description: Number of subscription period intervals
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for the subscription period (e.g. month, year)
        tax_inclusive:
          type: boolean
          description: Indicates if the recurring_pre_tax_amount is tax inclusive
        trial_period_days:
          type: integer
          format: int32
          description: Number of days in the trial period (0 if no trial)
    SubscriptionResponse:
      type: object
      description: Response struct representing subscription details
      required:
        - subscription_id
        - recurring_pre_tax_amount
        - tax_inclusive
        - currency
        - status
        - created_at
        - product_id
        - quantity
        - trial_period_days
        - subscription_period_interval
        - payment_frequency_interval
        - subscription_period_count
        - payment_frequency_count
        - next_billing_date
        - previous_billing_date
        - customer
        - metadata
        - cancel_at_next_billing_date
        - billing
        - on_demand
        - addons
      properties:
        addons:
          type: array
          items:
            $ref: '#/components/schemas/AddonCartResponseItem'
          description: Addons associated with this subscription
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for payments
        cancel_at_next_billing_date:
          type: boolean
          description: Indicates if the subscription will cancel at the next billing date
        cancelled_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Cancelled timestamp if the subscription is cancelled
        created_at:
          type: string
          format: date-time
          description: Timestamp when the subscription was created
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency used for the subscription payments
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Customer details associated with the subscription
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the subscription
        next_billing_date:
          type: string
          format: date-time
          description: Timestamp of the next scheduled billing. Indicates the end of current billing period
        on_demand:
          type: boolean
          description: Wether the subscription is on-demand or not
        payment_frequency_count:
          type: integer
          format: int32
          description: Number of payment frequency intervals
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for payment frequency (e.g. month, year)
        previous_billing_date:
          type: string
          format: date-time
          description: Timestamp of the last payment. Indicates the start of current billing period
        product_id:
          type: string
          description: Identifier of the product associated with this subscription
        quantity:
          type: integer
          format: int32
          description: Number of units/items included in the subscription
        recurring_pre_tax_amount:
          type: integer
          format: int32
          description: Amount charged before tax for each recurring payment in smallest currency unit (e.g. cents)
        status:
          $ref: '#/components/schemas/SubscriptionStatus'
          description: Current status of the subscription
        subscription_id:
          type: string
          description: Unique identifier for the subscription
        subscription_period_count:
          type: integer
          format: int32
          description: Number of subscription period intervals
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for the subscription period (e.g. month, year)
        tax_inclusive:
          type: boolean
          description: Indicates if the recurring_pre_tax_amount is tax inclusive
        trial_period_days:
          type: integer
          format: int32
          description: Number of days in the trial period (0 if no trial)
    SubscriptionStatus:
      type: string
      enum:
        - pending
        - active
        - on_hold
        - cancelled
        - failed
        - expired
    TaxCategory:
      type: string
      description: Represents the different categories of taxation applicable to various products and services.
      enum:
        - digital_products
        - saas
        - e_book
        - edtech
    TimeInterval:
      type: string
      enum:
        - Day
        - Week
        - Month
        - Year
    UpdateAddonImageResponse:
      type: object
      required:
        - url
        - image_id
      properties:
        image_id:
          type: string
          format: uuid
        url:
          type: string
    UpdateBrandImageResponse:
      type: object
      required:
        - url
        - image_id
      properties:
        image_id:
          type: string
          format: uuid
          description: UUID that will be used as the image identifier/key suffix
        url:
          type: string
          description: Presigned URL to upload the image
    UpdateProductImageResponse:
      type: object
      required:
        - url
      properties:
        image_id:
          type:
            - string
            - 'null'
          format: uuid
        url:
          type: string
    UpdateSubscriptionPlanReq:
      type: object
      required:
        - product_id
        - quantity
        - proration_billing_mode
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/AttachAddonReq'
          description: |-
            Addons for the new plan.
            Note : Leaving this empty would remove any existing addons
        product_id:
          type: string
          description: Unique identifier of the product to subscribe to
        proration_billing_mode:
          $ref: '#/components/schemas/ProrationBillingMode'
          description: Proration Billing Mode
        quantity:
          type: integer
          format: int32
          description: Number of units to subscribe for. Must be at least 1.
          minimum: 0
    UploadProductFile:
      type: object
      required:
        - file_name
      properties:
        file_name:
          type: string
    UploadProductFileResponse:
      type: object
      required:
        - url
        - file_id
      properties:
        file_id:
          type: string
          format: uuid
        url:
          type: string
    ValidateLicenseKeyRequest:
      type: object
      required:
        - license_key
      properties:
        license_key:
          type: string
          example: 2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43
        license_key_instance_id:
          type:
            - string
            - 'null'
          example: lki_123
    ValidateLicenseKeyResponse:
      type: object
      required:
        - valid
      properties:
        valid:
          type: boolean
          example: true
    WebhookEventLogResponse:
      type: object
      required:
        - event_id
        - business_id
        - event_type
        - object_id
        - created_at
      properties:
        business_id:
          type: string
        created_at:
          type: string
          format: date-time
        event_id:
          type: string
        event_type:
          type: string
        latest_attempted_at:
          type:
            - string
            - 'null'
          format: date-time
        object_id:
          type: string
        request:
          type:
            - string
            - 'null'
        response:
          type:
            - string
            - 'null'
  securitySchemes:
    API_KEY:
      type: http
      scheme: bearer
tags:
  - name: Products
  - name: Payments
  - name: Subscriptions
  - name: Addons
  - name: Customers
  - name: Refunds
  - name: Disputes
  - name: License Keys
  - name: Licenses
  - name: Discounts
  - name: Outgoing Webhooks
  - name: Checkout
  - name: Webhook Events