openapi: 3.1.0
info:
  title: public
  description: ''
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0
  version: 1.52.1
servers:
  - url: https://test.dodopayments.com/
    description: Test Mode Server Host
  - url: https://live.dodopayments.com/
    description: Live Mode Server Host
paths:
  /addons:
    get:
      tags:
        - Addons
      operationId: list_addons
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
      responses:
        '200':
          description: List all addons
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const addonResponse of client.addons.list()) {
              console.log(addonResponse.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.addons.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Addons.List(context.TODO(), dodopayments.AddonListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.addons.list

            puts(page)
    post:
      tags:
        - Addons
      operationId: create_addon
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateAddonRequest'
        required: true
      responses:
        '200':
          description: Create a new addon
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const addonResponse = await client.addons.create({
              currency: 'AED',
              name: 'name',
              price: 0,
              tax_category: 'digital_products',
            });

            console.log(addonResponse.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            addon_response = client.addons.create(
                currency="AED",
                name="name",
                price=0,
                tax_category="digital_products",
            )
            print(addon_response.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              addonResponse, err := client.Addons.New(context.TODO(), dodopayments.AddonNewParams{
                Currency: dodopayments.F(dodopayments.CurrencyAed),
                Name: dodopayments.F("name"),
                Price: dodopayments.F(int64(0)),
                TaxCategory: dodopayments.F(dodopayments.TaxCategoryDigitalProducts),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", addonResponse.ID)
            }
        - lang: Ruby
          source: >-
            require "dodopayments"


            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )


            addon_response = dodo_payments.addons.create(currency: :AED, name: "name", price: 0, tax_category:
            :digital_products)


            puts(addon_response)
  /addons/{id}:
    get:
      tags:
        - Addons
      operationId: get_addon_handler
      parameters:
        - name: id
          in: path
          description: Addon Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Retrieve a specific addon
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const addonResponse = await client.addons.retrieve('id');

            console.log(addonResponse.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            addon_response = client.addons.retrieve(
                "id",
            )
            print(addon_response.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              addonResponse, err := client.Addons.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", addonResponse.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            addon_response = dodo_payments.addons.retrieve("id")

            puts(addon_response)
    patch:
      tags:
        - Addons
      operationId: patch_addon
      parameters:
        - name: id
          in: path
          description: Addon Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchAddonRequest'
        required: true
      responses:
        '200':
          description: Patch update an addon
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AddonResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const addonResponse = await client.addons.update('id');

            console.log(addonResponse.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            addon_response = client.addons.update(
                id="id",
            )
            print(addon_response.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              addonResponse, err := client.Addons.Update(
                context.TODO(),
                "id",
                dodopayments.AddonUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", addonResponse.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            addon_response = dodo_payments.addons.update("id")

            puts(addon_response)
  /addons/{id}/images:
    put:
      tags:
        - Addons
      operationId: update_addon_image
      parameters:
        - name: id
          in: path
          description: Addon Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Generate presigned upload URL for addon image
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UpdateAddonImageResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.addons.updateImages('id');

            console.log(response.image_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.addons.update_images(
                "id",
            )
            print(response.image_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Addons.UpdateImages(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.ImageID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.addons.update_images("id")

            puts(response)
  /brands:
    get:
      tags:
        - Brands
      operationId: list_brands_handler
      responses:
        '200':
          description: List all brands
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListBrandsResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brands = await client.brands.list();

            console.log(brands.items);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brands = client.brands.list()
            print(brands.items)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brands, err := client.Brands.List(context.TODO())
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brands.Items)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brands = dodo_payments.brands.list

            puts(brands)
    post:
      tags:
        - Brands
      operationId: create_brand_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateBrandRequest'
        required: true
      responses:
        '200':
          description: Created Brand
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BrandResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brand = await client.brands.create();

            console.log(brand.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brand = client.brands.create()
            print(brand.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brand, err := client.Brands.New(context.TODO(), dodopayments.BrandNewParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brand.BrandID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brand = dodo_payments.brands.create

            puts(brand)
  /brands/{id}:
    get:
      tags:
        - Brands
      summary: Thin handler just calls `get_brand` and wraps in `Json(...)`
      operationId: get_brand_handler
      parameters:
        - name: id
          in: path
          description: Brand Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Get a single brand
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BrandResponse'
        '404':
          description: Brand not found
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brand = await client.brands.retrieve('id');

            console.log(brand.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brand = client.brands.retrieve(
                "id",
            )
            print(brand.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brand, err := client.Brands.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brand.BrandID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brand = dodo_payments.brands.retrieve("id")

            puts(brand)
    patch:
      tags:
        - Brands
      operationId: patch_brand_handler
      parameters:
        - name: id
          in: path
          description: Brand Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchBrandRequest'
        required: true
      responses:
        '200':
          description: Updated Brand
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BrandResponse'
        '403':
          description: Primary brand cannot be updated via this API endpoint
        '404':
          description: Brand not found
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const brand = await client.brands.update('id');

            console.log(brand.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            brand = client.brands.update(
                id="id",
            )
            print(brand.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              brand, err := client.Brands.Update(
                context.TODO(),
                "id",
                dodopayments.BrandUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", brand.BrandID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            brand = dodo_payments.brands.update("id")

            puts(brand)
  /brands/{id}/images:
    put:
      tags:
        - Brands
      operationId: update_brand_image
      parameters:
        - name: id
          in: path
          description: Brand Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Generate presigned upload URL for brand image
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UpdateBrandImageResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.brands.updateImages('id');

            console.log(response.image_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.brands.update_images(
                "id",
            )
            print(response.image_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Brands.UpdateImages(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.ImageID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.brands.update_images("id")

            puts(response)
  /checkout/supported_countries:
    get:
      tags:
        - Checkout
      operationId: get_supported_countries_proxy
      responses:
        '200':
          description: Currently Supported Countries
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/CountryCodeAlpha2'
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const countryCodes = await client.misc.listSupportedCountries();

            console.log(countryCodes);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            country_codes = client.misc.list_supported_countries()
            print(country_codes)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              countryCodes, err := client.Misc.ListSupportedCountries(context.TODO())
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", countryCodes)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            country_codes = dodo_payments.misc.list_supported_countries

            puts(country_codes)
  /checkouts:
    post:
      tags:
        - Checkout Sessions
      operationId: create_session
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateCheckoutSessionRequest'
        required: true
      responses:
        '200':
          description: Checkout session successfully created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateSessionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const checkoutSessionResponse = await client.checkoutSessions.create({
              product_cart: [{ product_id: 'product_id', quantity: 0 }],
            });

            console.log(checkoutSessionResponse.session_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            checkout_session_response = client.checkout_sessions.create(
                product_cart=[{
                    "product_id": "product_id",
                    "quantity": 0,
                }],
            )
            print(checkout_session_response.session_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              checkoutSessionResponse, err := client.CheckoutSessions.New(context.TODO(), dodopayments.CheckoutSessionNewParams{
                CheckoutSessionRequest: dodopayments.CheckoutSessionRequestParam{
                  ProductCart: dodopayments.F([]dodopayments.CheckoutSessionRequestProductCartParam{dodopayments.CheckoutSessionRequestProductCartParam{
                    ProductID: dodopayments.F("product_id"),
                    Quantity: dodopayments.F(int64(0)),
                  }}),
                },
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", checkoutSessionResponse.SessionID)
            }
        - lang: Ruby
          source: >-
            require "dodopayments"


            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )


            checkout_session_response = dodo_payments.checkout_sessions.create(product_cart: [{product_id:
            "product_id", quantity: 0}])


            puts(checkout_session_response)
  /customers:
    get:
      tags:
        - Customers
      operationId: list_customers
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: email
          in: query
          description: Filter by customer email
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: Customers List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetCustomersListResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const customer of client.customers.list()) {
              console.log(customer.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.customers.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Customers.List(context.TODO(), dodopayments.CustomerListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.customers.list

            puts(page)
    post:
      tags:
        - Customers
      operationId: create_customer
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateCustomerRequest'
        required: true
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CustomerResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customer = await client.customers.create({ email: 'email', name: 'name' });

            console.log(customer.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer = client.customers.create(
                email="email",
                name="name",
            )
            print(customer.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customer, err := client.Customers.New(context.TODO(), dodopayments.CustomerNewParams{
                Email: dodopayments.F("email"),
                Name: dodopayments.F("name"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customer.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer = dodo_payments.customers.create(email: "email", name: "name")

            puts(customer)
  /customers/{customer_id}:
    get:
      tags:
        - Customers
      operationId: get_customer_handler
      parameters:
        - name: customer_id
          in: path
          description: Customer Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CustomerResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customer = await client.customers.retrieve('customer_id');

            console.log(customer.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer = client.customers.retrieve(
                "customer_id",
            )
            print(customer.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customer, err := client.Customers.Get(context.TODO(), "customer_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customer.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer = dodo_payments.customers.retrieve("customer_id")

            puts(customer)
    patch:
      tags:
        - Customers
      operationId: patch_customer
      parameters:
        - name: customer_id
          in: path
          description: Customer Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchCustomerRequest'
        required: true
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CustomerResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customer = await client.customers.update('customer_id');

            console.log(customer.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer = client.customers.update(
                customer_id="customer_id",
            )
            print(customer.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customer, err := client.Customers.Update(
                context.TODO(),
                "customer_id",
                dodopayments.CustomerUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customer.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer = dodo_payments.customers.update("customer_id")

            puts(customer)
  /customers/{customer_id}/customer-portal/session:
    post:
      tags:
        - Customers
      operationId: create_customer_portal_session
      parameters:
        - name: send_email
          in: query
          description: If true, will send link to user.
          required: false
          schema:
            type: boolean
          style: form
        - name: customer_id
          in: path
          description: Customer Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successfully send email to customer (if they exist)
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateCustomerPortalSessionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const customerPortalSession = await client.customers.customerPortal.create('customer_id');

            console.log(customerPortalSession.link);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            customer_portal_session = client.customers.customer_portal.create(
                customer_id="customer_id",
            )
            print(customer_portal_session.link)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              customerPortalSession, err := client.Customers.CustomerPortal.New(
                context.TODO(),
                "customer_id",
                dodopayments.CustomerCustomerPortalNewParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", customerPortalSession.Link)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            customer_portal_session = dodo_payments.customers.customer_portal.create("customer_id")

            puts(customer_portal_session)
  /discounts:
    get:
      tags:
        - Discounts
      summary: GET /discounts
      operationId: list_discounts_handler
      parameters:
        - name: page_size
          in: query
          description: Page size (default = 10, max = 100).
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number (default = 0).
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
      responses:
        '200':
          description: List of active Discounts
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetDiscountsListResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const discount of client.discounts.list()) {
              console.log(discount.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.discounts.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Discounts.List(context.TODO(), dodopayments.DiscountListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.discounts.list

            puts(page)
    post:
      tags:
        - Discounts
      summary: |-
        POST /discounts
        If `code` is omitted or empty, a random 16-char uppercase code is generated.
      operationId: create_discount_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateDiscountRequest'
        required: true
      responses:
        '200':
          description: Created discount
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiscountResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const discount = await client.discounts.create({ amount: 0, type: 'percentage' });

            console.log(discount.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            discount = client.discounts.create(
                amount=0,
                type="percentage",
            )
            print(discount.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              discount, err := client.Discounts.New(context.TODO(), dodopayments.DiscountNewParams{
                Amount: dodopayments.F(int64(0)),
                Type: dodopayments.F(dodopayments.DiscountTypePercentage),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", discount.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            discount = dodo_payments.discounts.create(amount: 0, type: :percentage)

            puts(discount)
  /discounts/{discount_id}:
    get:
      tags:
        - Discounts
      summary: GET /discounts/{discount_id}
      operationId: get_discount_handler
      parameters:
        - name: discount_id
          in: path
          description: Discount Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Fetched discount by ID
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiscountResponse'
        '404':
          description: Not found / or soft-deleted
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const discount = await client.discounts.retrieve('discount_id');

            console.log(discount.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            discount = client.discounts.retrieve(
                "discount_id",
            )
            print(discount.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              discount, err := client.Discounts.Get(context.TODO(), "discount_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", discount.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            discount = dodo_payments.discounts.retrieve("discount_id")

            puts(discount)
    delete:
      tags:
        - Discounts
      summary: DELETE /discounts/{discount_id}
      operationId: delete_discount_handler
      parameters:
        - name: discount_id
          in: path
          description: Discount Id
          required: true
          schema:
            type: string
      responses:
        '204':
          description: Soft-deleted discount (no content)
        '404':
          description: Discount not found or already deleted
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.discounts.delete('discount_id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.discounts.delete(
                "discount_id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Discounts.Delete(context.TODO(), "discount_id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.discounts.delete("discount_id")

            puts(result)
    patch:
      tags:
        - Discounts
      summary: PATCH /discounts/{discount_id}
      operationId: patch_discount_handler
      parameters:
        - name: discount_id
          in: path
          description: Discount Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchDiscountRequest'
        required: true
      responses:
        '200':
          description: Updated discount
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DiscountResponse'
        '404':
          description: Discount not found or soft-deleted
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const discount = await client.discounts.update('discount_id');

            console.log(discount.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            discount = client.discounts.update(
                discount_id="discount_id",
            )
            print(discount.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              discount, err := client.Discounts.Update(
                context.TODO(),
                "discount_id",
                dodopayments.DiscountUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", discount.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            discount = dodo_payments.discounts.update("discount_id")

            puts(discount)
  /disputes:
    get:
      tags:
        - Disputes
      operationId: list_disputes
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: dispute_status
          in: query
          description: Filter by dispute status
          required: false
          schema:
            type: string
            enum:
              - dispute_opened
              - dispute_expired
              - dispute_accepted
              - dispute_cancelled
              - dispute_challenged
              - dispute_won
              - dispute_lost
          style: form
        - name: dispute_stage
          in: query
          description: Filter by dispute stage
          required: false
          schema:
            type: string
            enum:
              - pre_dispute
              - dispute
              - pre_arbitration
          style: form
        - name: customer_id
          in: query
          description: Filter by customer_id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetDisputesListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const disputeListResponse of client.disputes.list()) {
              console.log(disputeListResponse.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.disputes.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Disputes.List(context.TODO(), dodopayments.DisputeListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.disputes.list

            puts(page)
  /disputes/{dispute_id}:
    get:
      tags:
        - Disputes
      operationId: get_dispute_handler
      parameters:
        - name: dispute_id
          in: path
          description: Dispute Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetDisputeResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const getDispute = await client.disputes.retrieve('dispute_id');

            console.log(getDispute.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            get_dispute = client.disputes.retrieve(
                "dispute_id",
            )
            print(get_dispute.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              getDispute, err := client.Disputes.Get(context.TODO(), "dispute_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", getDispute.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            get_dispute = dodo_payments.disputes.retrieve("dispute_id")

            puts(get_dispute)
  /events:
    get:
      tags:
        - Events
      summary: Retrieve events with advanced filtering and pagination
      description: >-
        Fetch events from your account with powerful filtering capabilities. This endpoint is ideal for:

        - Debugging event ingestion issues

        - Analyzing customer usage patterns

        - Building custom analytics dashboards

        - Auditing billing-related events


        ## Filtering Options:

        - **Customer filtering**: Filter by specific customer ID

        - **Event name filtering**: Filter by event type/name

        - **Meter-based filtering**: Use a meter ID to apply the meter's event name and filter criteria
        automatically

        - **Time range filtering**: Filter events within a specific date range

        - **Pagination**: Navigate through large result sets


        ## Meter Integration:

        When using `meter_id`, the endpoint automatically applies:

        - The meter's configured `event_name` filter

        - The meter's custom filter criteria (if any)

        - If you also provide `event_name`, it must match the meter's event name


        ## Example Queries:

        - Get all events for a customer: `?customer_id=cus_abc123`

        - Get API request events: `?event_name=api_request`

        - Get events from last 24 hours: `?start=2024-01-14T10:30:00Z&end=2024-01-15T10:30:00Z`

        - Get events with meter filtering: `?meter_id=mtr_xyz789`

        - Paginate results: `?page_size=50&page_number=2`
      operationId: get_events
      parameters:
        - name: customer_id
          in: query
          description: Filter events by customer ID
          required: false
          schema:
            type: string
          style: form
        - name: event_name
          in: query
          description: >-
            Filter events by event name. If both event_name and meter_id are provided, they must match the
            meter's configured event_name
          required: false
          schema:
            type: string
          style: form
        - name: meter_id
          in: query
          description: >-
            Filter events by meter ID. When provided, only events that match the meter's event_name and filter
            criteria will be returned
          required: false
          schema:
            type: string
          style: form
        - name: page_size
          in: query
          description: 'Number of events to return per page (default: 10)'
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: 'Page number (0-based, default: 0)'
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: start
          in: query
          description: Filter events created after this timestamp
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: end
          in: query
          description: Filter events created before this timestamp
          required: false
          schema:
            type: string
            format: date-time
          style: form
      responses:
        '200':
          description: Events retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetEventsResponse'
        '400':
          description: Invalid request - invalid query parameters, conflicting meter/event names, or malformed dates
        '401':
          description: Unauthorized - invalid or missing API key
        '404':
          description: Meter not found - the specified meter_id does not exist
        '422':
          description: Unprocessable entity - validation errors in query parameters
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const event of client.usageEvents.list()) {
              console.log(event.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.usage_events.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.UsageEvents.List(context.TODO(), dodopayments.UsageEventListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.usage_events.list

            puts(page)
  /events/ingest:
    post:
      tags:
        - Events
      summary: Ingest events for usage-based billing and analytics
      description: >-
        This endpoint allows you to ingest custom events that can be used for:

        - Usage-based billing and metering

        - Analytics and reporting

        - Customer behavior tracking


        ## Important Notes:

        - **Duplicate Prevention**:
          - Duplicate `event_id` values within the same request are rejected (entire request fails)
          - Subsequent requests with existing `event_id` values are ignored (idempotent behavior)
        - **Rate Limiting**: Maximum 1000 events per request

        - **Time Validation**: Events with timestamps older than 1 hour or more than 5 minutes in the future
        will be rejected

        - **Metadata Limits**: Maximum 50 key-value pairs per event, keys max 100 chars, values max 500 chars


        ## Example Usage:

        ```json

        {
          "events": [
            {
              "event_id": "api_call_12345",
              "customer_id": "cus_abc123",
              "event_name": "api_request",
              "timestamp": "2024-01-15T10:30:00Z",
              "metadata": {
                "endpoint": "/api/v1/users",
                "method": "GET",
                "tokens_used": "150"
              }
            }
          ]
        }

        ```
      operationId: ingest_events
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IngestEventsRequest'
        required: true
      responses:
        '200':
          description: Events ingested successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IngestEventsResponse'
        '400':
          description: Invalid request - validation errors, duplicate event IDs, or invalid timestamps
        '401':
          description: Unauthorized - invalid or missing API key
        '413':
          description: Payload too large - request exceeds maximum allowed size
        '422':
          description: Unprocessable entity - malformed JSON or schema validation errors
        '429':
          description: Too many requests - rate limit exceeded
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.usageEvents.ingest({
              events: [{ customer_id: 'customer_id', event_id: 'event_id', event_name: 'event_name' }],
            });

            console.log(response.ingested_count);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.usage_events.ingest(
                events=[{
                    "customer_id": "customer_id",
                    "event_id": "event_id",
                    "event_name": "event_name",
                }],
            )
            print(response.ingested_count)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.UsageEvents.Ingest(context.TODO(), dodopayments.UsageEventIngestParams{
                Events: dodopayments.F([]dodopayments.EventInputParam{dodopayments.EventInputParam{
                  CustomerID: dodopayments.F("customer_id"),
                  EventID: dodopayments.F("event_id"),
                  EventName: dodopayments.F("event_name"),
                }}),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.IngestedCount)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.usage_events.ingest(
              events: [{customer_id: "customer_id", event_id: "event_id", event_name: "event_name"}]
            )

            puts(response)
  /events/{event_id}:
    get:
      tags:
        - Events
      summary: Retrieve a specific event by its unique ID
      description: >-
        Fetch detailed information about a single event using its unique event ID. This endpoint is useful
        for:

        - Debugging specific event ingestion issues

        - Retrieving event details for customer support

        - Validating that events were processed correctly

        - Getting the complete metadata for an event


        ## Event ID Format:

        The event ID should be the same value that was provided during event ingestion via the
        `/events/ingest` endpoint.

        Event IDs are case-sensitive and must match exactly.


        ## Response Details:

        The response includes all event data including:

        - Complete metadata key-value pairs

        - Original timestamp (preserved from ingestion)

        - Customer and business association

        - Event name and processing information


        ## Example Usage:

        ```text

        GET /events/api_call_12345

        ```
      operationId: get_event_by_id
      parameters:
        - name: event_id
          in: path
          description: Unique event identifier (case-sensitive, must match the ID used during ingestion)
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Event retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Event'
        '401':
          description: Unauthorized - invalid or missing API key
        '404':
          description: Event not found - no event exists with the specified ID for your business
        '422':
          description: Unprocessable entity - invalid event ID format
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const event = await client.usageEvents.retrieve('event_id');

            console.log(event.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            event = client.usage_events.retrieve(
                "event_id",
            )
            print(event.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              event, err := client.UsageEvents.Get(context.TODO(), "event_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", event.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            event = dodo_payments.usage_events.retrieve("event_id")

            puts(event)
  /invoices/payments/{payment_id}:
    get:
      tags:
        - Invoices
      operationId: get_payment_invoice_no_auth
      parameters:
        - name: payment_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: PDF document
          content:
            application/pdf:
              schema:
                type: array
                items:
                  type: integer
                  format: int32
                  minimum: 0
        '429':
          description: Too Many Requests have been sent
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const payment = await client.invoices.payments.retrieve('payment_id');

            console.log(payment);

            const content = await payment.blob();
            console.log(content);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            payment = client.invoices.payments.retrieve(
                "payment_id",
            )
            print(payment)
            content = payment.read()
            print(content)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              payment, err := client.Invoices.Payments.Get(context.TODO(), "payment_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", payment)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            payment = dodo_payments.invoices.payments.retrieve("payment_id")

            puts(payment)
  /invoices/refunds/{refund_id}:
    get:
      tags:
        - Invoices
      operationId: get_refund_invoice_no_auth
      parameters:
        - name: refund_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: PDF document
          content:
            application/pdf:
              schema:
                type: array
                items:
                  type: integer
                  format: int32
                  minimum: 0
        '429':
          description: Too Many Requests have been sent
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.invoices.payments.retrieveRefund('refund_id');

            console.log(response);

            const content = await response.blob();
            console.log(content);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.invoices.payments.retrieve_refund(
                "refund_id",
            )
            print(response)
            content = response.read()
            print(content)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Invoices.Payments.GetRefund(context.TODO(), "refund_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.invoices.payments.retrieve_refund("refund_id")

            puts(response)
  /license_key_instances:
    get:
      tags:
        - License Keys
      operationId: list_license_key_instances
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
            minimum: 0
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
            minimum: 0
        - name: license_key_id
          in: query
          description: Filter by license key ID
          required: false
          schema:
            type:
              - string
              - 'null'
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListLicenseKeyInstancesResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const licenseKeyInstance of client.licenseKeyInstances.list()) {
              console.log(licenseKeyInstance.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.license_key_instances.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.LicenseKeyInstances.List(context.TODO(), dodopayments.LicenseKeyInstanceListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.license_key_instances.list

            puts(page)
  /license_key_instances/{id}:
    get:
      tags:
        - License Keys
      operationId: get_license_key_instance
      parameters:
        - name: id
          in: path
          description: License key instance ID
          required: true
          schema:
            type: string
          example: lki_123
      responses:
        '200':
          description: License key instance found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyInstanceResponse'
        '404':
          description: License key instance not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKeyInstance = await client.licenseKeyInstances.retrieve('lki_123');

            console.log(licenseKeyInstance.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key_instance = client.license_key_instances.retrieve(
                "id",
            )
            print(license_key_instance.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKeyInstance, err := client.LicenseKeyInstances.Get(context.TODO(), "lki_123")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKeyInstance.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key_instance = dodo_payments.license_key_instances.retrieve("id")

            puts(license_key_instance)
    patch:
      tags:
        - License Keys
      operationId: update_license_key_instance
      parameters:
        - name: id
          in: path
          description: License key instance ID
          required: true
          schema:
            type: string
          example: lki_123
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchLicenseKeyInstanceRequest'
        required: true
      responses:
        '200':
          description: License key instance updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyInstanceResponse'
        '404':
          description: License key instance not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKeyInstance = await client.licenseKeyInstances.update('lki_123', { name: 'name' });

            console.log(licenseKeyInstance.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key_instance = client.license_key_instances.update(
                id="lki_123",
                name="name",
            )
            print(license_key_instance.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKeyInstance, err := client.LicenseKeyInstances.Update(
                context.TODO(),
                "lki_123",
                dodopayments.LicenseKeyInstanceUpdateParams{
                  Name: dodopayments.F("name"),
                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKeyInstance.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key_instance = dodo_payments.license_key_instances.update("id", name: "name")

            puts(license_key_instance)
  /license_keys:
    get:
      tags:
        - License Keys
      operationId: list_license_keys_handler
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: customer_id
          in: query
          description: Filter by customer ID
          required: false
          schema:
            type: string
          style: form
        - name: status
          in: query
          description: Filter by license key status
          required: false
          schema:
            type: string
            enum:
              - active
              - expired
              - disabled
          style: form
        - name: product_id
          in: query
          description: Filter by product ID
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListLicenseKeysResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const licenseKey of client.licenseKeys.list()) {
              console.log(licenseKey.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.license_keys.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.LicenseKeys.List(context.TODO(), dodopayments.LicenseKeyListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.license_keys.list

            puts(page)
  /license_keys/{id}:
    get:
      tags:
        - License Keys
      operationId: get_license_key_handler
      parameters:
        - name: id
          in: path
          description: License key ID
          required: true
          schema:
            type: string
          example: lic_123
      responses:
        '200':
          description: License key found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyResponse'
        '404':
          description: License key not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKey = await client.licenseKeys.retrieve('lic_123');

            console.log(licenseKey.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key = client.license_keys.retrieve(
                "id",
            )
            print(license_key.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKey, err := client.LicenseKeys.Get(context.TODO(), "lic_123")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKey.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key = dodo_payments.license_keys.retrieve("id")

            puts(license_key)
    patch:
      tags:
        - License Keys
      operationId: update_license_key
      parameters:
        - name: id
          in: path
          description: License key ID
          required: true
          schema:
            type: string
          example: lic_123
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchLicenseKeyRequest'
        required: true
      responses:
        '200':
          description: License key updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyResponse'
        '400':
          description: Cannot set expiry for subscription-based license
        '404':
          description: License key not found
        '422':
          description: New activation limit is less than current instances count
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const licenseKey = await client.licenseKeys.update('lic_123');

            console.log(licenseKey.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key = client.license_keys.update(
                id="lic_123",
            )
            print(license_key.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKey, err := client.LicenseKeys.Update(
                context.TODO(),
                "lic_123",
                dodopayments.LicenseKeyUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKey.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key = dodo_payments.license_keys.update("id")

            puts(license_key)
  /licenses/activate:
    post:
      tags:
        - Licenses
      operationId: activate_license_key
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ActivateLicenseKeyRequest'
        required: true
      responses:
        '201':
          description: License key instance created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LicenseKeyInstanceResponse'
        '403':
          description: License key cannot be activated (inactive)
        '404':
          description: License key not found
        '422':
          description: License key activation limit reached
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: >-
            import DodoPayments from 'dodopayments';


            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });


            const licenseKeyInstance = await client.licenses.activate({ license_key: 'license_key', name:
            'name' });


            console.log(licenseKeyInstance.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            license_key_instance = client.licenses.activate(
                license_key="license_key",
                name="name",
            )
            print(license_key_instance.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              licenseKeyInstance, err := client.Licenses.Activate(context.TODO(), dodopayments.LicenseActivateParams{
                LicenseKey: dodopayments.F("license_key"),
                Name: dodopayments.F("name"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", licenseKeyInstance.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            license_key_instance = dodo_payments.licenses.activate(license_key: "license_key", name: "name")

            puts(license_key_instance)
  /licenses/deactivate:
    post:
      tags:
        - Licenses
      operationId: deactivate_license_key
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DeactivateLicenseKeyRequest'
        required: true
      responses:
        '200':
          description: License key instance deactivated successfully
        '403':
          description: License key instance not found or does not belong to this license key
        '404':
          description: License key not found
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.licenses.deactivate({
              license_key: 'license_key',
              license_key_instance_id: 'license_key_instance_id',
            });
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.licenses.deactivate(
                license_key="license_key",
                license_key_instance_id="license_key_instance_id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Licenses.Deactivate(context.TODO(), dodopayments.LicenseDeactivateParams{
                LicenseKey: dodopayments.F("license_key"),
                LicenseKeyInstanceID: dodopayments.F("license_key_instance_id"),
              })
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.licenses.deactivate(
              license_key: "license_key",
              license_key_instance_id: "license_key_instance_id"
            )

            puts(result)
  /licenses/validate:
    post:
      tags:
        - Licenses
      operationId: validate_license_key
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ValidateLicenseKeyRequest'
        required: true
      responses:
        '200':
          description: License key validation result
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ValidateLicenseKeyResponse'
        '422':
          description: Invalid request format
        '500':
          description: Something went wrong :(
      x-codeSamples:
        - lang: JavaScript
          source: >-
            import DodoPayments from 'dodopayments';


            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });


            const response = await client.licenses.validate({ license_key:
            '2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43' });


            console.log(response.valid);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.licenses.validate(
                license_key="2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43",
            )
            print(response.valid)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Licenses.Validate(context.TODO(), dodopayments.LicenseValidateParams{
                LicenseKey: dodopayments.F("2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.Valid)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.licenses.validate(license_key: "2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43")

            puts(response)
  /meters:
    get:
      tags:
        - Meters
      operationId: list_meters_handler
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: archived
          in: query
          description: List archived meters
          required: false
          schema:
            type: boolean
          style: form
      responses:
        '200':
          description: Meters List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListMetersResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const meter of client.meters.list()) {
              console.log(meter.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.meters.list()
            page = page.items[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Meters.List(context.TODO(), dodopayments.MeterListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.meters.list

            puts(page)
    post:
      tags:
        - Meters
      operationId: create_meter
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateMeterRequest'
        required: true
      responses:
        '201':
          description: Meter created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MeterResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const meter = await client.meters.create({
              aggregation: { type: 'count' },
              event_name: 'event_name',
              measurement_unit: 'measurement_unit',
              name: 'name',
            });

            console.log(meter.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            meter = client.meters.create(
                aggregation={
                    "type": "count"
                },
                event_name="event_name",
                measurement_unit="measurement_unit",
                name="name",
            )
            print(meter.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              meter, err := client.Meters.New(context.TODO(), dodopayments.MeterNewParams{
                Aggregation: dodopayments.F(dodopayments.MeterAggregationParam{
                  Type: dodopayments.F(dodopayments.MeterAggregationTypeCount),
                }),
                EventName: dodopayments.F("event_name"),
                MeasurementUnit: dodopayments.F("measurement_unit"),
                Name: dodopayments.F("name"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", meter.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            meter = dodo_payments.meters.create(
              aggregation: {type: :count},
              event_name: "event_name",
              measurement_unit: "measurement_unit",
              name: "name"
            )

            puts(meter)
  /meters/{id}:
    get:
      tags:
        - Meters
      operationId: get_meter_handler
      parameters:
        - name: id
          in: path
          description: Meter ID
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Meter details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MeterResponse'
        '404':
          description: Meter not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const meter = await client.meters.retrieve('id');

            console.log(meter.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            meter = client.meters.retrieve(
                "id",
            )
            print(meter.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              meter, err := client.Meters.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", meter.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            meter = dodo_payments.meters.retrieve("id")

            puts(meter)
    delete:
      tags:
        - Meters
      operationId: delete_meter
      parameters:
        - name: id
          in: path
          description: Meter ID
          required: true
          schema:
            type: string
      responses:
        '204':
          description: Meter deleted successfully
        '404':
          description: Meter not found
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.meters.archive('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.meters.archive(
                "id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Meters.Archive(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.meters.archive("id")

            puts(result)
  /meters/{id}/unarchive:
    post:
      tags:
        - Meters
      operationId: unarchive_meter
      parameters:
        - name: id
          in: path
          description: Meter ID
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Meter Unarchived Successfully
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.meters.unarchive('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.meters.unarchive(
                "id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Meters.Unarchive(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.meters.unarchive("id")

            puts(result)
  /payments:
    get:
      tags:
        - Payments
      operationId: list_payments_handler
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: customer_id
          in: query
          description: Filter by customer id
          required: false
          schema:
            type: string
          style: form
        - name: subscription_id
          in: query
          description: Filter by subscription id
          required: false
          schema:
            type: string
          style: form
        - name: status
          in: query
          description: Filter by status
          required: false
          schema:
            type: string
            enum:
              - succeeded
              - failed
              - cancelled
              - processing
              - requires_customer_action
              - requires_merchant_action
              - requires_payment_method
              - requires_confirmation
              - requires_capture
              - partially_captured
              - partially_captured_and_capturable
          style: form
        - name: brand_id
          in: query
          description: filter by Brand id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetPaymentsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const paymentListResponse of client.payments.list()) {
              console.log(paymentListResponse.brand_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.payments.list()
            page = page.items[0]
            print(page.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Payments.List(context.TODO(), dodopayments.PaymentListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.payments.list

            puts(page)
    post:
      tags:
        - Payments
      operationId: create_one_time_payment_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOneTimePaymentRequest'
        required: true
      responses:
        '200':
          description: One Time payment successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateOneTimePaymentResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const payment = await client.payments.create({
              billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 'zipcode' },
              customer: { customer_id: 'customer_id' },
              product_cart: [{ product_id: 'product_id', quantity: 0 }],
            });

            console.log(payment.payment_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            payment = client.payments.create(
                billing={
                    "city": "city",
                    "country": "AF",
                    "state": "state",
                    "street": "street",
                    "zipcode": "zipcode",
                },
                customer={
                    "customer_id": "customer_id"
                },
                product_cart=[{
                    "product_id": "product_id",
                    "quantity": 0,
                }],
            )
            print(payment.payment_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              payment, err := client.Payments.New(context.TODO(), dodopayments.PaymentNewParams{
                Billing: dodopayments.F(dodopayments.BillingAddressParam{
                  City: dodopayments.F("city"),
                  Country: dodopayments.F(dodopayments.CountryCodeAf),
                  State: dodopayments.F("state"),
                  Street: dodopayments.F("street"),
                  Zipcode: dodopayments.F("zipcode"),
                }),
                Customer: dodopayments.F[dodopayments.CustomerRequestUnionParam](dodopayments.AttachExistingCustomerParam{
                  CustomerID: dodopayments.F("customer_id"),
                }),
                ProductCart: dodopayments.F([]dodopayments.OneTimeProductCartItemParam{dodopayments.OneTimeProductCartItemParam{
                  ProductID: dodopayments.F("product_id"),
                  Quantity: dodopayments.F(int64(0)),
                }}),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", payment.PaymentID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            payment = dodo_payments.payments.create(
              billing: {city: "city", country: :AF, state: "state", street: "street", zipcode: "zipcode"},
              customer: {customer_id: "customer_id"},
              product_cart: [{product_id: "product_id", quantity: 0}]
            )

            puts(payment)
  /payments/{payment_id}:
    get:
      tags:
        - Payments
      operationId: get_payment_handler
      parameters:
        - name: payment_id
          in: path
          description: Payment Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const payment = await client.payments.retrieve('payment_id');

            console.log(payment.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            payment = client.payments.retrieve(
                "payment_id",
            )
            print(payment.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              payment, err := client.Payments.Get(context.TODO(), "payment_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", payment.BrandID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            payment = dodo_payments.payments.retrieve("payment_id")

            puts(payment)
  /payments/{payment_id}/line-items:
    get:
      tags:
        - Payments
      operationId: get_payment_line_items_handler
      parameters:
        - name: payment_id
          in: path
          description: Payment Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaymentLineItemsResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.payments.retrieveLineItems('payment_id');

            console.log(response.currency);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.payments.retrieve_line_items(
                "payment_id",
            )
            print(response.currency)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Payments.GetLineItems(context.TODO(), "payment_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.Currency)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.payments.retrieve_line_items("payment_id")

            puts(response)
  /payouts:
    get:
      tags:
        - Payouts
      operationId: list_payouts
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
      responses:
        '200':
          description: Payouts List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetPayoutsResponseList'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const payoutListResponse of client.payouts.list()) {
              console.log(payoutListResponse.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.payouts.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Payouts.List(context.TODO(), dodopayments.PayoutListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.payouts.list

            puts(page)
  /products:
    get:
      tags:
        - Products
      operationId: list_products_handler
      parameters:
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: archived
          in: query
          description: List archived products
          required: false
          schema:
            type: boolean
          style: form
        - name: recurring
          in: query
          description: |-
            Filter products by pricing type:
            - `true`: Show only recurring pricing products (e.g. subscriptions)
            - `false`: Show only one-time price products
            - `null` or absent: Show both types of products
          required: false
          schema:
            type: boolean
          style: form
        - name: brand_id
          in: query
          description: filter by Brand id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: Products List
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetProductsListResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const productListResponse of client.products.list()) {
              console.log(productListResponse.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.products.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Products.List(context.TODO(), dodopayments.ProductListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.products.list

            puts(page)
    post:
      tags:
        - Products
      operationId: create_product
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateProductRequest'
        required: true
      responses:
        '200':
          description: Product Created Successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetProductResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const product = await client.products.create({
              price: { currency: 'AED', discount: 0, price: 0, purchasing_power_parity: true, type: 'one_time_price' },
              tax_category: 'digital_products',
            });

            console.log(product.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            product = client.products.create(
                price={
                    "currency": "AED",
                    "discount": 0,
                    "price": 0,
                    "purchasing_power_parity": True,
                    "type": "one_time_price",
                },
                tax_category="digital_products",
            )
            print(product.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              product, err := client.Products.New(context.TODO(), dodopayments.ProductNewParams{
                Price: dodopayments.F[dodopayments.PriceUnionParam](dodopayments.PriceOneTimePriceParam{
                  Currency: dodopayments.F(dodopayments.CurrencyAed),
                  Discount: dodopayments.F(int64(0)),
                  Price: dodopayments.F(int64(0)),
                  PurchasingPowerParity: dodopayments.F(true),
                  Type: dodopayments.F(dodopayments.PriceOneTimePriceTypeOneTimePrice),
                }),
                TaxCategory: dodopayments.F(dodopayments.TaxCategoryDigitalProducts),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", product.BrandID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            product = dodo_payments.products.create(
              price: {currency: :AED, discount: 0, price: 0, purchasing_power_parity: true, type: :one_time_price},
              tax_category: :digital_products
            )

            puts(product)
  /products/{id}:
    get:
      tags:
        - Products
      operationId: get_product_handler
      parameters:
        - name: id
          in: path
          description: Product Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Product Details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetProductResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const product = await client.products.retrieve('id');

            console.log(product.brand_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            product = client.products.retrieve(
                "id",
            )
            print(product.brand_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              product, err := client.Products.Get(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", product.BrandID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            product = dodo_payments.products.retrieve("id")

            puts(product)
    delete:
      tags:
        - Products
      operationId: delete_product
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Product Delected Successfully
        '410':
          description: Product is deleted
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.products.archive('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.products.archive(
                "id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Products.Archive(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.products.archive("id")

            puts(result)
    patch:
      tags:
        - Products
      operationId: patch_product
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchProductRequest'
        required: true
      responses:
        '200':
          description: Product Updated Successfully
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.products.update('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.products.update(
                id="id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Products.Update(
                context.TODO(),
                "id",
                dodopayments.ProductUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.products.update("id")

            puts(result)
  /products/{id}/files:
    put:
      tags:
        - Products
      operationId: upload_product_file
      parameters:
        - name: id
          in: path
          description: Product Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UploadProductFile'
        required: true
      responses:
        '200':
          description: Aws s3 presigned URL. Upload image to this URL within 60s
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UploadProductFileResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.products.updateFiles('id', { file_name: 'file_name' });

            console.log(response.file_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.products.update_files(
                id="id",
                file_name="file_name",
            )
            print(response.file_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Products.UpdateFiles(
                context.TODO(),
                "id",
                dodopayments.ProductUpdateFilesParams{
                  FileName: dodopayments.F("file_name"),
                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.FileID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.products.update_files("id", file_name: "file_name")

            puts(response)
  /products/{id}/images:
    put:
      tags:
        - Products
      operationId: update_product_image
      parameters:
        - name: id
          in: path
          description: Product Id
          required: true
          schema:
            type: string
        - name: force_update
          in: query
          required: false
          schema:
            type: boolean
          style: form
      responses:
        '200':
          description: Aws s3 presigned URL. Upload image to this URL within 60s
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UpdateProductImageResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const image = await client.products.images.update('id');

            console.log(image.image_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            image = client.products.images.update(
                id="id",
            )
            print(image.image_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              image, err := client.Products.Images.Update(
                context.TODO(),
                "id",
                dodopayments.ProductImageUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", image.ImageID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            image = dodo_payments.products.images.update("id")

            puts(image)
  /products/{id}/unarchive:
    post:
      tags:
        - Products
      operationId: undelete_product
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Product Delected Successfully
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.products.unarchive('id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.products.unarchive(
                "id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Products.Unarchive(context.TODO(), "id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.products.unarchive("id")

            puts(result)
  /refunds:
    get:
      tags:
        - Refunds
      operationId: list_refunds
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: status
          in: query
          description: Filter by status
          required: false
          schema:
            type: string
            enum:
              - succeeded
              - failed
              - pending
              - review
          style: form
        - name: customer_id
          in: query
          description: Filter by customer_id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetRefundsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const refund of client.refunds.list()) {
              console.log(refund.business_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.refunds.list()
            page = page.items[0]
            print(page.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Refunds.List(context.TODO(), dodopayments.RefundListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.refunds.list

            puts(page)
    post:
      tags:
        - Refunds
      operationId: create_refund_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateRefundRequest'
        required: true
      responses:
        '200':
          description: Refund successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RefundResponse'
        '400':
          description: Invalid Request Parameters
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const refund = await client.refunds.create({ payment_id: 'payment_id' });

            console.log(refund.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            refund = client.refunds.create(
                payment_id="payment_id",
            )
            print(refund.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              refund, err := client.Refunds.New(context.TODO(), dodopayments.RefundNewParams{
                PaymentID: dodopayments.F("payment_id"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", refund.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            refund = dodo_payments.refunds.create(payment_id: "payment_id")

            puts(refund)
  /refunds/{refund_id}:
    get:
      tags:
        - Refunds
      operationId: get_refund_handler
      parameters:
        - name: refund_id
          in: path
          description: Refund Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RefundResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const refund = await client.refunds.retrieve('refund_id');

            console.log(refund.business_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            refund = client.refunds.retrieve(
                "refund_id",
            )
            print(refund.business_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              refund, err := client.Refunds.Get(context.TODO(), "refund_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", refund.BusinessID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            refund = dodo_payments.refunds.retrieve("refund_id")

            puts(refund)
  /subscriptions:
    get:
      tags:
        - Subscriptions
      operationId: list_subscriptions_handler
      parameters:
        - name: created_at_gte
          in: query
          description: Get events after this created time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: created_at_lte
          in: query
          description: Get events created before this time
          required: false
          schema:
            type: string
            format: date-time
          style: form
        - name: page_size
          in: query
          description: Page size default is 10 max is 100
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: page_number
          in: query
          description: Page number default is 0
          required: false
          schema:
            type: integer
            format: int32
            minimum: 0
          style: form
        - name: customer_id
          in: query
          description: Filter by customer id
          required: false
          schema:
            type: string
          style: form
        - name: status
          in: query
          description: Filter by status
          required: false
          schema:
            type: string
            enum:
              - pending
              - active
              - on_hold
              - cancelled
              - failed
              - expired
          style: form
        - name: brand_id
          in: query
          description: filter by Brand id
          required: false
          schema:
            type: string
          style: form
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetSubscriptionsListResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const subscriptionListResponse of client.subscriptions.list()) {
              console.log(subscriptionListResponse.product_id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.subscriptions.list()
            page = page.items[0]
            print(page.product_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Subscriptions.List(context.TODO(), dodopayments.SubscriptionListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.subscriptions.list

            puts(page)
    post:
      tags:
        - Subscriptions
      operationId: create_subscription_handler
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateSubscriptionRequest'
        required: true
      responses:
        '200':
          description: Subscription successfully initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateSubscriptionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const subscription = await client.subscriptions.create({
              billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 'zipcode' },
              customer: { customer_id: 'customer_id' },
              product_id: 'product_id',
              quantity: 0,
            });

            console.log(subscription.payment_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            subscription = client.subscriptions.create(
                billing={
                    "city": "city",
                    "country": "AF",
                    "state": "state",
                    "street": "street",
                    "zipcode": "zipcode",
                },
                customer={
                    "customer_id": "customer_id"
                },
                product_id="product_id",
                quantity=0,
            )
            print(subscription.payment_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              subscription, err := client.Subscriptions.New(context.TODO(), dodopayments.SubscriptionNewParams{
                Billing: dodopayments.F(dodopayments.BillingAddressParam{
                  City: dodopayments.F("city"),
                  Country: dodopayments.F(dodopayments.CountryCodeAf),
                  State: dodopayments.F("state"),
                  Street: dodopayments.F("street"),
                  Zipcode: dodopayments.F("zipcode"),
                }),
                Customer: dodopayments.F[dodopayments.CustomerRequestUnionParam](dodopayments.AttachExistingCustomerParam{
                  CustomerID: dodopayments.F("customer_id"),
                }),
                ProductID: dodopayments.F("product_id"),
                Quantity: dodopayments.F(int64(0)),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", subscription.PaymentID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            subscription = dodo_payments.subscriptions.create(
              billing: {city: "city", country: :AF, state: "state", street: "street", zipcode: "zipcode"},
              customer: {customer_id: "customer_id"},
              product_id: "product_id",
              quantity: 0
            )

            puts(subscription)
  /subscriptions/{subscription_id}:
    get:
      tags:
        - Subscriptions
      operationId: get_subscription_handler
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubscriptionResponse'
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const subscription = await client.subscriptions.retrieve('subscription_id');

            console.log(subscription.product_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            subscription = client.subscriptions.retrieve(
                "subscription_id",
            )
            print(subscription.product_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              subscription, err := client.Subscriptions.Get(context.TODO(), "subscription_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", subscription.ProductID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            subscription = dodo_payments.subscriptions.retrieve("subscription_id")

            puts(subscription)
    patch:
      tags:
        - Subscriptions
      operationId: patch_subscription_handler
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchSubscriptionRequest'
        required: true
      responses:
        '200':
          description: Subscription successfully updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubscriptionResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const subscription = await client.subscriptions.update('subscription_id');

            console.log(subscription.product_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            subscription = client.subscriptions.update(
                subscription_id="subscription_id",
            )
            print(subscription.product_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              subscription, err := client.Subscriptions.Update(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", subscription.ProductID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            subscription = dodo_payments.subscriptions.update("subscription_id")

            puts(subscription)
  /subscriptions/{subscription_id}/change-plan:
    post:
      tags:
        - Subscriptions
      operationId: update_subscription_plan_handler
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateSubscriptionPlanReq'
        required: true
      responses:
        '200':
          description: Subscription plan changed
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.subscriptions.changePlan('subscription_id', {
              product_id: 'product_id',
              proration_billing_mode: 'prorated_immediately',
              quantity: 0,
            });
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.subscriptions.change_plan(
                subscription_id="subscription_id",
                product_id="product_id",
                proration_billing_mode="prorated_immediately",
                quantity=0,
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Subscriptions.ChangePlan(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionChangePlanParams{
                  ProductID: dodopayments.F("product_id"),
                  ProrationBillingMode: dodopayments.F(dodopayments.SubscriptionChangePlanParamsProrationBillingModeProratedImmediately),
                  Quantity: dodopayments.F(int64(0)),
                },
              )
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.subscriptions.change_plan(
              "subscription_id",
              product_id: "product_id",
              proration_billing_mode: :prorated_immediately,
              quantity: 0
            )

            puts(result)
  /subscriptions/{subscription_id}/charge:
    post:
      tags:
        - Subscriptions
      operationId: create_subscription_charge
      parameters:
        - name: subscription_id
          in: path
          description: Subscription Id
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateSubscriptionChargeRequest'
        required: true
      responses:
        '200':
          description: Subscription Charge successfully created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateSubscriptionChargeResponse'
        '422':
          description: Invalid Request Object or Parameters
        '500':
          description: Something went wrong :(
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.subscriptions.charge('subscription_id', { product_price: 0 });

            console.log(response.payment_id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.subscriptions.charge(
                subscription_id="subscription_id",
                product_price=0,
            )
            print(response.payment_id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Subscriptions.Charge(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionChargeParams{
                  ProductPrice: dodopayments.F(int64(0)),
                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.PaymentID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.subscriptions.charge("subscription_id", product_price: 0)

            puts(response)
  /subscriptions/{subscription_id}/usage-history:
    get:
      tags:
        - Subscriptions
      summary: Retrieve usage-based billing history for a subscription
      description: |-
        Get detailed usage history for a subscription that includes usage-based billing (metered components).
        This endpoint provides insights into customer usage patterns and billing calculations over time.

        ## What You'll Get:
        - **Billing periods**: Each item represents a billing cycle with start and end dates
        - **Meter usage**: Detailed breakdown of usage for each meter configured on the subscription
        - **Usage calculations**: Total units consumed, free threshold units, and chargeable units
        - **Historical tracking**: Complete audit trail of usage-based charges

        ## Use Cases:
        - **Customer support**: Investigate billing questions and usage discrepancies
        - **Usage analytics**: Analyze customer consumption patterns over time
        - **Billing transparency**: Provide customers with detailed usage breakdowns
        - **Revenue optimization**: Identify usage trends to optimize pricing strategies

        ## Filtering Options:
        - **Date range filtering**: Get usage history for specific time periods
        - **Meter-specific filtering**: Focus on usage for a particular meter
        - **Pagination**: Navigate through large usage histories efficiently

        ## Important Notes:
        - Only returns data for subscriptions with usage-based (metered) components
        - Usage history is organized by billing periods (subscription cycles)
        - Free threshold units are calculated and displayed separately from chargeable units
        - Historical data is preserved even if meter configurations change

        ## Example Query Patterns:
        - Get last 3 months: `?start_date=2024-01-01T00:00:00Z&end_date=2024-03-31T23:59:59Z`
        - Filter by meter: `?meter_id=mtr_api_requests`
        - Paginate results: `?page_size=20&page_number=1`
        - Recent usage: `?start_date=2024-03-01T00:00:00Z` (from March 1st to now)
      operationId: list_usage_history_handler
      parameters:
        - name: subscription_id
          in: path
          description: Unique subscription identifier
          required: true
          schema:
            type: string
        - name: start_date
          in: query
          description: Filter by start date (inclusive)
          required: false
          schema:
            type:
              - string
              - 'null'
            format: date-time
        - name: end_date
          in: query
          description: Filter by end date (inclusive)
          required: false
          schema:
            type:
              - string
              - 'null'
            format: date-time
        - name: meter_id
          in: query
          description: Filter by specific meter ID
          required: false
          schema:
            type:
              - string
              - 'null'
        - name: page_size
          in: query
          description: 'Page size (default: 10, max: 100)'
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
            minimum: 0
        - name: page_number
          in: query
          description: 'Page number (default: 0)'
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
            minimum: 0
      responses:
        '200':
          description: Usage history retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListUsageHistoryResponse'
        '400':
          description: Invalid request - malformed parameters or validation errors
        '401':
          description: Unauthorized - invalid or missing API key
        '404':
          description: Subscription not found - no subscription exists with the specified ID
        '422':
          description: Unprocessable entity - invalid query parameter values or date ranges
        '500':
          description: Internal server error - please contact support if this persists
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: >-
            import DodoPayments from 'dodopayments';


            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });


            // Automatically fetches more pages as needed.

            for await (const subscriptionRetrieveUsageHistoryResponse of
            client.subscriptions.retrieveUsageHistory(
              'subscription_id',
            )) {
              console.log(subscriptionRetrieveUsageHistoryResponse.end_date);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.subscriptions.retrieve_usage_history(
                subscription_id="subscription_id",
            )
            page = page.items[0]
            print(page.end_date)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Subscriptions.GetUsageHistory(
                context.TODO(),
                "subscription_id",
                dodopayments.SubscriptionGetUsageHistoryParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.subscriptions.retrieve_usage_history("subscription_id")

            puts(page)
  /webhooks:
    get:
      tags:
        - Webhooks
      summary: List all webhooks
      operationId: list_webhooks
      parameters:
        - name: limit
          in: query
          description: Limit the number of returned items
          required: false
          schema:
            type:
              - integer
              - 'null'
            format: int32
        - name: iterator
          in: query
          description: The iterator returned from a prior invocation
          required: false
          schema:
            type:
              - string
              - 'null'
      responses:
        '200':
          description: List of endpoints
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListWebhooksResponse'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            // Automatically fetches more pages as needed.
            for await (const webhookDetails of client.webhooks.list()) {
              console.log(webhookDetails.id);
            }
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            page = client.webhooks.list()
            page = page.data[0]
            print(page.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              page, err := client.Webhooks.List(context.TODO(), dodopayments.WebhookListParams{

              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", page)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            page = dodo_payments.webhooks.list

            puts(page)
    post:
      tags:
        - Webhooks
      summary: Create a new webhook
      operationId: create_webhook
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateWebhookRequest'
        required: true
      responses:
        '200':
          description: Endpoint created Successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WebhookDetails'
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const webhookDetails = await client.webhooks.create({ url: 'url' });

            console.log(webhookDetails.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            webhook_details = client.webhooks.create(
                url="url",
            )
            print(webhook_details.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              webhookDetails, err := client.Webhooks.New(context.TODO(), dodopayments.WebhookNewParams{
                URL: dodopayments.F("url"),
              })
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", webhookDetails.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            webhook_details = dodo_payments.webhooks.create(url: "url")

            puts(webhook_details)
  /webhooks/{webhook_id}:
    get:
      tags:
        - Webhooks
      summary: Get a webhook by id
      operationId: get_webhook
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Webhook details retrived.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WebhookDetails'
        '404':
          description: Endpoint Not Found
        '500':
          description: Something went wrong.
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const webhookDetails = await client.webhooks.retrieve('webhook_id');

            console.log(webhookDetails.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            webhook_details = client.webhooks.retrieve(
                "webhook_id",
            )
            print(webhook_details.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              webhookDetails, err := client.Webhooks.Get(context.TODO(), "webhook_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", webhookDetails.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            webhook_details = dodo_payments.webhooks.retrieve("webhook_id")

            puts(webhook_details)
    delete:
      tags:
        - Webhooks
      summary: Delete a webhook by id
      operationId: delete_webhook
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Webhook has been deleted
        '404':
          description: Endpoint Not Found
        '500':
          description: Something went wrong.
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.webhooks.delete('webhook_id');
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.webhooks.delete(
                "webhook_id",
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Webhooks.Delete(context.TODO(), "webhook_id")
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.webhooks.delete("webhook_id")

            puts(result)
    patch:
      tags:
        - Webhooks
      summary: Patch a webhook by id
      operationId: patch_webhook
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PatchWebhookRequest'
        required: true
      responses:
        '200':
          description: Webhook patched successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WebhookDetails'
        '404':
          description: Webhook Not Found
        '500':
          description: Something went wrong.
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const webhookDetails = await client.webhooks.update('webhook_id');

            console.log(webhookDetails.id);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            webhook_details = client.webhooks.update(
                webhook_id="webhook_id",
            )
            print(webhook_details.id)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              webhookDetails, err := client.Webhooks.Update(
                context.TODO(),
                "webhook_id",
                dodopayments.WebhookUpdateParams{

                },
              )
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", webhookDetails.ID)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            webhook_details = dodo_payments.webhooks.update("webhook_id")

            puts(webhook_details)
  /webhooks/{webhook_id}/headers:
    get:
      tags:
        - Webhooks
      summary: Get a webhook by id
      operationId: get_webhook_headers
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Webhook headers details retrived.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetWebhookHeadersResponse'
        '404':
          description: Endpoint Not Found
        '500':
          description: Something went wrong.
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const header = await client.webhooks.headers.retrieve('webhook_id');

            console.log(header.headers);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            header = client.webhooks.headers.retrieve(
                "webhook_id",
            )
            print(header.headers)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              header, err := client.Webhooks.Headers.Get(context.TODO(), "webhook_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", header.Headers)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            header = dodo_payments.webhooks.headers.retrieve("webhook_id")

            puts(header)
    patch:
      tags:
        - Webhooks
      summary: Patch a webhook by id
      operationId: patch_webhook_headers
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/WebhookHeadersReq'
        required: true
      responses:
        '200':
          description: Webhook headers patched successfully
        '404':
          description: Webhook Not Found
        '500':
          description: Something went wrong.
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            await client.webhooks.headers.update('webhook_id', { headers: { foo: 'string' } });
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            client.webhooks.headers.update(
                webhook_id="webhook_id",
                headers={
                    "foo": "string"
                },
            )
        - lang: Go
          source: |
            package main

            import (
              "context"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              err := client.Webhooks.Headers.Update(
                context.TODO(),
                "webhook_id",
                dodopayments.WebhookHeaderUpdateParams{
                  Headers: dodopayments.F(map[string]string{
                  "foo": "string",
                  }),
                },
              )
              if err != nil {
                panic(err.Error())
              }
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            result = dodo_payments.webhooks.headers.update("webhook_id", headers: {foo: "string"})

            puts(result)
  /webhooks/{webhook_id}/secret:
    get:
      tags:
        - Webhooks
      summary: Get webhook secret by id
      operationId: get_webhook_secret
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Webhook secret retrived.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetWebhookSecretResponse'
        '404':
          description: Endpoint Not Found
        '500':
          description: Something went wrong.
      security:
        - API_KEY: []
      x-codeSamples:
        - lang: JavaScript
          source: |-
            import DodoPayments from 'dodopayments';

            const client = new DodoPayments({
              bearerToken: 'My Bearer Token',
            });

            const response = await client.webhooks.retrieveSecret('webhook_id');

            console.log(response.secret);
        - lang: Python
          source: |-
            from dodopayments import DodoPayments

            client = DodoPayments(
                bearer_token="My Bearer Token",
            )
            response = client.webhooks.retrieve_secret(
                "webhook_id",
            )
            print(response.secret)
        - lang: Go
          source: |
            package main

            import (
              "context"
              "fmt"

              "github.com/dodopayments/dodopayments-go"
              "github.com/dodopayments/dodopayments-go/option"
            )

            func main() {
              client := dodopayments.NewClient(
                option.WithBearerToken("My Bearer Token"),
              )
              response, err := client.Webhooks.GetSecret(context.TODO(), "webhook_id")
              if err != nil {
                panic(err.Error())
              }
              fmt.Printf("%+v\n", response.Secret)
            }
        - lang: Ruby
          source: |-
            require "dodopayments"

            dodo_payments = Dodopayments::Client.new(
              bearer_token: "My Bearer Token",
              environment: "test_mode" # defaults to "live_mode"
            )

            response = dodo_payments.webhooks.retrieve_secret("webhook_id")

            puts(response)
  /your-webhook-url:
    post:
      tags:
        - Outgoing Webhooks
      operationId: dummy_handler_for_outgoing_webhook_docs
      parameters:
        - name: webhook-id
          in: header
          description: Unique identifier for the webhook
          required: true
          schema:
            type: string
        - name: webhook-signature
          in: header
          description: Signature of the Webhook
          required: true
          schema:
            type: string
        - name: webhook-timestamp
          in: header
          description: Unix timestamp when the webhook was sent
          required: true
          schema:
            type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OutgoingWebhook'
        required: true
      responses:
        '200':
          description: Webhook processed successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
components:
  schemas:
    ActivateLicenseKeyRequest:
      type: object
      required:
        - name
        - license_key
      properties:
        license_key:
          type: string
        name:
          type: string
    AddMeterToPrice:
      type: object
      title: Add Meter To Price
      required:
        - meter_id
        - price_per_unit
      properties:
        description:
          type:
            - string
            - 'null'
          description: Meter description. Will ignored on Request, but will be shown in response
        free_threshold:
          type:
            - integer
            - 'null'
          format: int64
        measurement_unit:
          type:
            - string
            - 'null'
          description: Meter measurement unit. Will ignored on Request, but will be shown in response
        meter_id:
          type: string
        name:
          type:
            - string
            - 'null'
          description: Meter name. Will ignored on Request, but will be shown in response
        price_per_unit:
          type: string
          description: >-
            The price per unit in lowest denomination. Must be greater than zero. Supports up to 5 digits
            before decimal point and 12 decimal places.
          example: '10.50'
    AddonCartResponseItem:
      type: object
      title: Addon Cart Response Item
      description: Response struct representing subscription details
      required:
        - addon_id
        - quantity
      properties:
        addon_id:
          type: string
        quantity:
          type: integer
          format: int32
    AddonResponse:
      type: object
      required:
        - id
        - business_id
        - name
        - tax_category
        - price
        - currency
        - created_at
        - updated_at
      properties:
        business_id:
          type: string
          description: Unique identifier for the business to which the addon belongs.
        created_at:
          type: string
          format: date-time
          description: Created time
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency of the Addon
        description:
          type:
            - string
            - 'null'
          description: Optional description of the Addon
        id:
          type: string
          description: id of the Addon
        image:
          type:
            - string
            - 'null'
          description: Image of the Addon
        name:
          type: string
          description: Name of the Addon
        price:
          type: integer
          format: int32
          description: Amount of the addon
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category applied to this Addon
        updated_at:
          type: string
          format: date-time
          description: Updated time
    AddonsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/AddonResponse'
    AggregationType:
      type: string
      enum:
        - count
        - sum
        - unique_count
        - max
        - last
    AttachAddonReq:
      type: object
      title: Attach Addon Request
      required:
        - addon_id
        - quantity
      properties:
        addon_id:
          type: string
        quantity:
          type: integer
          format: int32
          minimum: 0
    AttachExistingCustomer:
      type: object
      title: Attach Existing Customer
      required:
        - customer_id
      properties:
        customer_id:
          type: string
    BillingAddress:
      type: object
      required:
        - country
        - state
        - city
        - street
        - zipcode
      properties:
        city:
          type: string
          description: City name
        country:
          $ref: '#/components/schemas/CountryCodeAlpha2'
          description: Two-letter ISO country code (ISO 3166-1 alpha-2)
        state:
          type: string
          description: State or province name
        street:
          type: string
          description: Street address including house number and unit/apartment if applicable
        zipcode:
          type: string
          description: Postal code or ZIP code
    BrandResponse:
      type: object
      required:
        - brand_id
        - business_id
        - enabled
        - statement_descriptor
        - verification_status
        - verification_enabled
      properties:
        brand_id:
          type: string
        business_id:
          type: string
        description:
          type:
            - string
            - 'null'
        enabled:
          type: boolean
        image:
          type:
            - string
            - 'null'
        name:
          type:
            - string
            - 'null'
        reason_for_hold:
          type:
            - string
            - 'null'
          description: Incase the brand verification fails or is put on hold
        statement_descriptor:
          type: string
        support_email:
          type:
            - string
            - 'null'
        url:
          type:
            - string
            - 'null'
        verification_enabled:
          type: boolean
        verification_status:
          $ref: '#/components/schemas/BrandVerificationStatus'
    BrandVerificationStatus:
      type: string
      enum:
        - Success
        - Fail
        - Review
        - Hold
    CheckoutSessionBillingAddress:
      type: object
      title: Checkout Session Billing Address
      required:
        - country
      properties:
        city:
          type:
            - string
            - 'null'
          description: City name
        country:
          $ref: '#/components/schemas/CountryCodeAlpha2'
          description: Two-letter ISO country code (ISO 3166-1 alpha-2)
        state:
          type:
            - string
            - 'null'
          description: State or province name
        street:
          type:
            - string
            - 'null'
          description: Street address including house number and unit/apartment if applicable
        zipcode:
          type:
            - string
            - 'null'
          description: Postal code or ZIP code
    CheckoutSessionCustomization:
      type: object
      title: Checkout Session Customization
      properties:
        show_on_demand_tag:
          type: boolean
          description: |-
            Show on demand tag

            Default is true
        show_order_details:
          type: boolean
          description: |-
            Show order details by default

            Default is true
        theme:
          $ref: '#/components/schemas/CheckoutTheme'
          description: |-
            Theme of the page

            Default is `System`.
    CheckoutSessionFlags:
      type: object
      title: Checkout Session Flags
      properties:
        allow_currency_selection:
          type: boolean
          description: |-
            if customer is allowed to change currency, set it to true

            Default is true
        allow_discount_code:
          type: boolean
          description: |-
            If the customer is allowed to apply discount code, set it to true.

            Default is true
        allow_phone_number_collection:
          type: boolean
          description: |-
            If phone number is collected from customer, set it to rue

            Default is true
        allow_tax_id:
          type: boolean
          description: |-
            If the customer is allowed to add tax id, set it to true

            Default is true
        always_create_new_customer:
          type: boolean
          description: |-
            Set to true if a new customer object should be created.
            By default email is used to find an existing customer to attach the session to

            Default is false
    CheckoutTheme:
      type: string
      enum:
        - dark
        - light
        - system
    Conjunction:
      type: string
      enum:
        - and
        - or
    CountryCodeAlpha2:
      type: string
      description: ISO country code alpha2 variant
      enum:
        - AF
        - AX
        - AL
        - DZ
        - AS
        - AD
        - AO
        - AI
        - AQ
        - AG
        - AR
        - AM
        - AW
        - AU
        - AT
        - AZ
        - BS
        - BH
        - BD
        - BB
        - BY
        - BE
        - BZ
        - BJ
        - BM
        - BT
        - BO
        - BQ
        - BA
        - BW
        - BV
        - BR
        - IO
        - BN
        - BG
        - BF
        - BI
        - KH
        - CM
        - CA
        - CV
        - KY
        - CF
        - TD
        - CL
        - CN
        - CX
        - CC
        - CO
        - KM
        - CG
        - CD
        - CK
        - CR
        - CI
        - HR
        - CU
        - CW
        - CY
        - CZ
        - DK
        - DJ
        - DM
        - DO
        - EC
        - EG
        - SV
        - GQ
        - ER
        - EE
        - ET
        - FK
        - FO
        - FJ
        - FI
        - FR
        - GF
        - PF
        - TF
        - GA
        - GM
        - GE
        - DE
        - GH
        - GI
        - GR
        - GL
        - GD
        - GP
        - GU
        - GT
        - GG
        - GN
        - GW
        - GY
        - HT
        - HM
        - VA
        - HN
        - HK
        - HU
        - IS
        - IN
        - ID
        - IR
        - IQ
        - IE
        - IM
        - IL
        - IT
        - JM
        - JP
        - JE
        - JO
        - KZ
        - KE
        - KI
        - KP
        - KR
        - KW
        - KG
        - LA
        - LV
        - LB
        - LS
        - LR
        - LY
        - LI
        - LT
        - LU
        - MO
        - MK
        - MG
        - MW
        - MY
        - MV
        - ML
        - MT
        - MH
        - MQ
        - MR
        - MU
        - YT
        - MX
        - FM
        - MD
        - MC
        - MN
        - ME
        - MS
        - MA
        - MZ
        - MM
        - NA
        - NR
        - NP
        - NL
        - NC
        - NZ
        - NI
        - NE
        - NG
        - NU
        - NF
        - MP
        - 'NO'
        - OM
        - PK
        - PW
        - PS
        - PA
        - PG
        - PY
        - PE
        - PH
        - PN
        - PL
        - PT
        - PR
        - QA
        - RE
        - RO
        - RU
        - RW
        - BL
        - SH
        - KN
        - LC
        - MF
        - PM
        - VC
        - WS
        - SM
        - ST
        - SA
        - SN
        - RS
        - SC
        - SL
        - SG
        - SX
        - SK
        - SI
        - SB
        - SO
        - ZA
        - GS
        - SS
        - ES
        - LK
        - SD
        - SR
        - SJ
        - SZ
        - SE
        - CH
        - SY
        - TW
        - TJ
        - TZ
        - TH
        - TL
        - TG
        - TK
        - TO
        - TT
        - TN
        - TR
        - TM
        - TC
        - TV
        - UG
        - UA
        - AE
        - GB
        - UM
        - US
        - UY
        - UZ
        - VU
        - VE
        - VN
        - VG
        - VI
        - WF
        - EH
        - YE
        - ZM
        - ZW
    CreateAddonRequest:
      type: object
      required:
        - name
        - tax_category
        - price
        - currency
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency of the Addon
        description:
          type:
            - string
            - 'null'
          description: Optional description of the Addon
        name:
          type: string
          description: Name of the Addon
        price:
          type: integer
          format: int32
          description: Amount of the addon
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category applied to this Addon
    CreateBrandRequest:
      type: object
      properties:
        description:
          type:
            - string
            - 'null'
        name:
          type:
            - string
            - 'null'
        statement_descriptor:
          type:
            - string
            - 'null'
        support_email:
          type:
            - string
            - 'null'
        url:
          type:
            - string
            - 'null'
    CreateCheckoutSessionRequest:
      type: object
      required:
        - product_cart
      properties:
        allowed_payment_method_types:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PaymentMethodTypes'
          description: |-
            Customers will never see payment methods that are not in this list.
            However, adding a method here does not guarantee customers will see it.
            Availability still depends on other factors (e.g., customer location, merchant settings).

            Disclaimar: Always provide 'credit' and 'debit' as a fallback.
            If all payment methods are unavailable, checkout session will fail.
          uniqueItems: true
        billing_address:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/CheckoutSessionBillingAddress'
              description: Billing address information for the session
        billing_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: This field is ingored if adaptive pricing is disabled
        confirm:
          type: boolean
          description: >-
            If confirm is true, all the details will be finalized. If required data is missing, an API error
            is thrown.
        customer:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/CustomerRequest'
              description: Customer details for the session
        customization:
          $ref: '#/components/schemas/CheckoutSessionCustomization'
          description: Customization for the checkout session page
        discount_code:
          type:
            - string
            - 'null'
        feature_flags:
          $ref: '#/components/schemas/CheckoutSessionFlags'
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Metadata'
              description: Additional metadata associated with the payment. Defaults to empty if not provided.
        product_cart:
          type: array
          items:
            $ref: '#/components/schemas/ProductItemReq'
        return_url:
          type:
            - string
            - 'null'
          description: The url to redirect after payment failure or success.
        show_saved_payment_methods:
          type: boolean
          description: Display saved payment methods of a returning customer False by default
        subscription_data:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/SubscriptionData'
    CreateCustomerPortalSessionResponse:
      type: object
      required:
        - link
      properties:
        link:
          type: string
    CreateCustomerRequest:
      type: object
      required:
        - name
        - email
      properties:
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    CreateDigitalProductDeliveryRequest:
      type: object
      title: Create Digital Product Delivery Request
      properties:
        external_url:
          type:
            - string
            - 'null'
          description: External URL to digital product
        instructions:
          type:
            - string
            - 'null'
          description: Instructions to download and use the digital product
    CreateDiscountRequest:
      type: object
      description: |-
        Request body for creating a discount.

        `code` is optional; if not provided, we generate a random 16-char code.
      required:
        - type
        - amount
      properties:
        amount:
          type: integer
          format: int32
          description: >-
            The discount amount.


            - If `discount_type` is **not** `percentage`, `amount` is in **USD cents**. For example, `100`
            means `$1.00`.
              Only USD is allowed.
            - If `discount_type` **is** `percentage`, `amount` is in **basis points**. For example, `540`
            means `5.4%`.


            Must be at least 1.
        code:
          type:
            - string
            - 'null'
          description: |-
            Optionally supply a code (will be uppercased).
            - Must be at least 3 characters if provided.
            - If omitted, a random 16-character code is generated.
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: When the discount expires, if ever.
        name:
          type:
            - string
            - 'null'
        restricted_to:
          type:
            - array
            - 'null'
          items:
            type: string
          description: List of product IDs to restrict usage (if any).
        subscription_cycles:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Number of subscription billing cycles this discount is valid for.
            If not provided, the discount will be applied indefinitely to
            all recurring payments related to the subscription.
        type:
          $ref: '#/components/schemas/DiscountType'
          description: The discount type (e.g. `percentage`, `flat`, or `flat_per_unit`).
        usage_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            How many times this discount can be used (if any).
            Must be >= 1 if provided.
    CreateMeterRequest:
      type: object
      required:
        - name
        - event_name
        - aggregation
        - measurement_unit
      properties:
        aggregation:
          $ref: '#/components/schemas/MeterAggregation'
          description: Aggregation configuration for the meter
        description:
          type:
            - string
            - 'null'
          description: Optional description of the meter
        event_name:
          type: string
          description: Event name to track
        filter:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/MeterFilter'
              description: Optional filter to apply to the meter
        measurement_unit:
          type: string
          description: measurement unit
        name:
          type: string
          description: Name of the meter
    CreateNewCustomer:
      type: object
      title: Create New Customer
      required:
        - name
        - email
      properties:
        create_new_customer:
          type: boolean
          description: |-
            When false, the most recently created customer object with the given email is used if exists.
            When true, a new customer object is always created
            False by default
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    CreateOneTimePaymentRequest:
      type: object
      title: Create One-Time Payment Request
      required:
        - product_cart
        - customer
        - billing
      properties:
        allowed_payment_method_types:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PaymentMethodTypes'
          description: |-
            List of payment methods allowed during checkout.

            Customers will **never** see payment methods that are **not** in this list.
            However, adding a method here **does not guarantee** customers will see it.
            Availability still depends on other factors (e.g., customer location, merchant settings).
          uniqueItems: true
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for the payment
        billing_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: |-
                Fix the currency in which the end customer is billed.
                If Dodo Payments cannot support that currency for this transaction, it will not proceed
        customer:
          $ref: '#/components/schemas/CustomerRequest'
          description: Customer information for the payment
        discount_code:
          type:
            - string
            - 'null'
          description: Discount Code to apply to the transaction
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: |-
            Additional metadata associated with the payment.
            Defaults to empty if not provided.
        payment_link:
          type:
            - boolean
            - 'null'
          description: Whether to generate a payment link. Defaults to false if not specified.
        product_cart:
          type: array
          items:
            $ref: '#/components/schemas/OneTimeProductCartItemReq'
          description: List of products in the cart. Must contain at least 1 and at most 100 items.
        return_url:
          type:
            - string
            - 'null'
          description: |-
            Optional URL to redirect the customer after payment.
            Must be a valid URL if provided.
        show_saved_payment_methods:
          type: boolean
          description: |-
            Display saved payment methods of a returning customer
            False by default
        tax_id:
          type:
            - string
            - 'null'
          description: Tax ID in case the payment is B2B. If tax id validation fails the payment creation will fail
    CreateOneTimePaymentResponse:
      type: object
      title: Create One-Time Payment Response
      required:
        - payment_id
        - total_amount
        - client_secret
        - customer
        - metadata
      properties:
        client_secret:
          type: string
          description: |-
            Client secret used to load Dodo checkout SDK
            NOTE : Dodo checkout SDK will be coming soon
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Limited details about the customer making the payment
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        expires_on:
          type:
            - string
            - 'null'
          format: date-time
          description: Expiry timestamp of the payment link
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional metadata associated with the payment
        payment_id:
          type: string
          description: Unique identifier for the payment
        payment_link:
          type:
            - string
            - 'null'
          description: Optional URL to a hosted payment page
        product_cart:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/OneTimeProductCartItemReq'
          description: Optional list of products included in the payment
        total_amount:
          type: integer
          format: int32
          description: Total amount of the payment in smallest currency unit (e.g. cents)
          minimum: 0
    CreateProductRequest:
      type: object
      required:
        - tax_category
        - price
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            type: string
          description: Addons available for subscription product
        brand_id:
          type:
            - string
            - 'null'
          description: Brand id for the product, if not provided will default to primary brand
        description:
          type:
            - string
            - 'null'
          description: Optional description of the product
        digital_product_delivery:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/CreateDigitalProductDeliveryRequest'
              description: Choose how you would like you digital product delivered
        license_key_activation_message:
          type:
            - string
            - 'null'
          description: Optional message displayed during license key activation
        license_key_activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            The number of times the license key can be activated.
            Must be 0 or greater
        license_key_duration:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/LicenseKeyDuration'
              description: |-
                Duration configuration for the license key.
                Set to null if you don't want the license key to expire.
                For subscriptions, the lifetime of the license key is tied to the subscription period
        license_key_enabled:
          type:
            - boolean
            - 'null'
          description: |-
            When true, generates and sends a license key to your customer.
            Defaults to false
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional metadata for the product
        name:
          type:
            - string
            - 'null'
          description: Optional name of the product
        price:
          $ref: '#/components/schemas/Price'
          description: Price configuration for the product
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category applied to this product
    CreateRefundRequest:
      type: object
      required:
        - payment_id
      properties:
        items:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PartialRefundItem'
          description: Partially Refund an Individual Item
        payment_id:
          type: string
          description: The unique identifier of the payment to be refunded.
        reason:
          type:
            - string
            - 'null'
          description: The reason for the refund, if any. Maximum length is 3000 characters. Optional.
    CreateSessionResponse:
      type: object
      required:
        - session_id
        - checkout_url
      properties:
        checkout_url:
          type: string
          description: Checkout url
        session_id:
          type: string
          description: The ID of the created checkout session
    CreateSubscriptionChargeRequest:
      type: object
      required:
        - product_price
      properties:
        adaptive_currency_fees_inclusive:
          type:
            - boolean
            - 'null'
          description: >-
            Whether adaptive currency fees should be included in the product_price (true) or added on top
            (false).

            This field is ignored if adaptive pricing is not enabled for the business.
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Metadata'
              description: Metadata for the payment. If not passed, the metadata of the subscription will be taken
        product_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: >-
                Optional currency of the product price. If not specified, defaults to the currency of the
                product.
        product_description:
          type:
            - string
            - 'null'
          description: |-
            Optional product description override for billing and line items.
            If not specified, the stored description of the product will be used.
        product_price:
          type: integer
          format: int32
          description: |-
            The product price. Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
    CreateSubscriptionChargeResponse:
      type: object
      required:
        - payment_id
      properties:
        payment_id:
          type: string
    CreateSubscriptionRequest:
      type: object
      description: |-
        Request payload for creating a new subscription

        This struct represents the data required to create a new subscription in the system.
        It includes details about the product, quantity, customer information, and billing details.
      required:
        - product_id
        - quantity
        - customer
        - billing
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/AttachAddonReq'
          description: Attach addons to this subscription
        allowed_payment_method_types:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/PaymentMethodTypes'
          description: |-
            List of payment methods allowed during checkout.

            Customers will **never** see payment methods that are **not** in this list.
            However, adding a method here **does not guarantee** customers will see it.
            Availability still depends on other factors (e.g., customer location, merchant settings).
          uniqueItems: true
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address information for the subscription
        billing_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: |-
                Fix the currency in which the end customer is billed.
                If Dodo Payments cannot support that currency for this transaction, it will not proceed
        customer:
          $ref: '#/components/schemas/CustomerRequest'
          description: Customer details for the subscription
        discount_code:
          type:
            - string
            - 'null'
          description: Discount Code to apply to the subscription
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: |-
            Additional metadata for the subscription
            Defaults to empty if not specified
        on_demand:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/OnDemandSubscriptionReq'
        payment_link:
          type:
            - boolean
            - 'null'
          description: |-
            If true, generates a payment link.
            Defaults to false if not specified.
        product_id:
          type: string
          description: Unique identifier of the product to subscribe to
        quantity:
          type: integer
          format: int32
          description: Number of units to subscribe for. Must be at least 1.
          minimum: 0
        return_url:
          type:
            - string
            - 'null'
          description: Optional URL to redirect after successful subscription creation
        show_saved_payment_methods:
          type: boolean
          description: |-
            Display saved payment methods of a returning customer
            False by default
        tax_id:
          type:
            - string
            - 'null'
          description: Tax ID in case the payment is B2B. If tax id validation fails the payment creation will fail
        trial_period_days:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Optional trial period in days
            If specified, this value overrides the trial period set in the product's price
            Must be between 0 and 10000 days
    CreateSubscriptionResponse:
      type: object
      required:
        - subscription_id
        - recurring_pre_tax_amount
        - customer
        - metadata
        - addons
        - payment_id
      properties:
        addons:
          type: array
          items:
            $ref: '#/components/schemas/AddonCartResponseItem'
          description: Addons associated with this subscription
        client_secret:
          type:
            - string
            - 'null'
          description: |-
            Client secret used to load Dodo checkout SDK
            NOTE : Dodo checkout SDK will be coming soon
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Customer details associated with this subscription
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        expires_on:
          type:
            - string
            - 'null'
          format: date-time
          description: Expiry timestamp of the payment link
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional metadata associated with the subscription
        payment_id:
          type: string
          description: First payment id for the subscription
        payment_link:
          type:
            - string
            - 'null'
          description: URL to checkout page
        recurring_pre_tax_amount:
          type: integer
          format: int32
          description: Tax will be added to the amount and charged to the customer on each billing cycle
          minimum: 0
        subscription_id:
          type: string
          description: Unique identifier for the subscription
    CreateWebhookRequest:
      type: object
      required:
        - url
      properties:
        description:
          type:
            - string
            - 'null'
        disabled:
          type:
            - boolean
            - 'null'
          description: |-
            Create the webhook in a disabled state.

            Default is false
        filter_types:
          type: array
          items:
            $ref: '#/components/schemas/EventType'
          description: |-
            Filter events to the webhook.

            Webhook event will only be sent for events in the list.
        headers:
          type:
            - object
            - 'null'
          description: Custom headers to be passed
          additionalProperties:
            type: string
          propertyNames:
            type: string
        idempotency_key:
          type:
            - string
            - 'null'
          description: The request's idempotency key
        metadata:
          type:
            - object
            - 'null'
          description: |-
            Metadata to be passed to the webhook
            Defaut is {}
          additionalProperties:
            type: string
          propertyNames:
            type: string
        rate_limit:
          type:
            - integer
            - 'null'
          format: int32
          minimum: 0
        url:
          type: string
          description: Url of the webhook
    Currency:
      type: string
      enum:
        - AED
        - ALL
        - AMD
        - ANG
        - AOA
        - ARS
        - AUD
        - AWG
        - AZN
        - BAM
        - BBD
        - BDT
        - BGN
        - BHD
        - BIF
        - BMD
        - BND
        - BOB
        - BRL
        - BSD
        - BWP
        - BYN
        - BZD
        - CAD
        - CHF
        - CLP
        - CNY
        - COP
        - CRC
        - CUP
        - CVE
        - CZK
        - DJF
        - DKK
        - DOP
        - DZD
        - EGP
        - ETB
        - EUR
        - FJD
        - FKP
        - GBP
        - GEL
        - GHS
        - GIP
        - GMD
        - GNF
        - GTQ
        - GYD
        - HKD
        - HNL
        - HRK
        - HTG
        - HUF
        - IDR
        - ILS
        - INR
        - IQD
        - JMD
        - JOD
        - JPY
        - KES
        - KGS
        - KHR
        - KMF
        - KRW
        - KWD
        - KYD
        - KZT
        - LAK
        - LBP
        - LKR
        - LRD
        - LSL
        - LYD
        - MAD
        - MDL
        - MGA
        - MKD
        - MMK
        - MNT
        - MOP
        - MRU
        - MUR
        - MVR
        - MWK
        - MXN
        - MYR
        - MZN
        - NAD
        - NGN
        - NIO
        - NOK
        - NPR
        - NZD
        - OMR
        - PAB
        - PEN
        - PGK
        - PHP
        - PKR
        - PLN
        - PYG
        - QAR
        - RON
        - RSD
        - RUB
        - RWF
        - SAR
        - SBD
        - SCR
        - SEK
        - SGD
        - SHP
        - SLE
        - SLL
        - SOS
        - SRD
        - SSP
        - STN
        - SVC
        - SZL
        - THB
        - TND
        - TOP
        - TRY
        - TTD
        - TWD
        - TZS
        - UAH
        - UGX
        - USD
        - UYU
        - UZS
        - VES
        - VND
        - VUV
        - WST
        - XAF
        - XCD
        - XOF
        - XPF
        - YER
        - ZAR
        - ZMW
    CustomerLimitedDetailsResponse:
      type: object
      required:
        - customer_id
        - name
        - email
      properties:
        customer_id:
          type: string
          description: Unique identifier for the customer
        email:
          type: string
          description: Email address of the customer
        name:
          type: string
          description: Full name of the customer
    CustomerRequest:
      oneOf:
        - $ref: '#/components/schemas/AttachExistingCustomer'
        - $ref: '#/components/schemas/NewCustomer'
      title: Customer Request
    CustomerResponse:
      type: object
      required:
        - customer_id
        - business_id
        - name
        - email
        - created_at
      properties:
        business_id:
          type: string
        created_at:
          type: string
          format: date-time
        customer_id:
          type: string
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    DeactivateLicenseKeyRequest:
      type: object
      required:
        - license_key
        - license_key_instance_id
      properties:
        license_key:
          type: string
        license_key_instance_id:
          type: string
    DigitalProductDelivery:
      type: object
      title: Digital Product Delivery
      properties:
        external_url:
          type:
            - string
            - 'null'
          description: External URL to digital product
        files:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/DigitalProductDeliveryFile'
          description: Uploaded files ids of digital product
        instructions:
          type:
            - string
            - 'null'
          description: Instructions to download and use the digital product
    DigitalProductDeliveryFile:
      type: object
      title: Digital Product Delivery File
      required:
        - file_id
        - file_name
        - url
      properties:
        file_id:
          type: string
          format: uuid
        file_name:
          type: string
        url:
          type: string
    DisableOnDemandReq:
      type: object
      title: Disable On Demand Request
      required:
        - next_billing_date
      properties:
        next_billing_date:
          type: string
          format: date-time
    DiscountResponse:
      type: object
      required:
        - discount_id
        - business_id
        - type
        - code
        - amount
        - times_used
        - restricted_to
        - created_at
      properties:
        amount:
          type: integer
          format: int32
          description: |-
            The discount amount.

            - If `discount_type` is `percentage`, this is in **basis points**
              (e.g., 540 => 5.4%).
            - Otherwise, this is **USD cents** (e.g., 100 => `$1.00`).
        business_id:
          type: string
          description: The business this discount belongs to.
        code:
          type: string
          description: The discount code (up to 16 chars).
        created_at:
          type: string
          format: date-time
          description: Timestamp when the discount is created
        discount_id:
          type: string
          description: The unique discount ID
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Optional date/time after which discount is expired.
        name:
          type:
            - string
            - 'null'
          description: Name for the Discount
        restricted_to:
          type: array
          items:
            type: string
          description: List of product IDs to which this discount is restricted.
        subscription_cycles:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Number of subscription billing cycles this discount is valid for.
            If not provided, the discount will be applied indefinitely to
            all recurring payments related to the subscription.
        times_used:
          type: integer
          format: int32
          description: How many times this discount has been used.
        type:
          $ref: '#/components/schemas/DiscountType'
          description: The type of discount, e.g. `percentage`, `flat`, or `flat_per_unit`.
        usage_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: Usage limit for this discount, if any.
    DiscountType:
      type: string
      enum:
        - percentage
    DisputeResponse:
      type: object
      required:
        - dispute_id
        - payment_id
        - business_id
        - amount
        - currency
        - dispute_status
        - dispute_stage
        - created_at
      properties:
        amount:
          type: string
          description: The amount involved in the dispute, represented as a string to accommodate precision.
        business_id:
          type: string
          description: The unique identifier of the business involved in the dispute.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the dispute was created, in UTC.
        currency:
          type: string
          description: The currency of the disputed amount, represented as an ISO 4217 currency code.
        dispute_id:
          type: string
          description: The unique identifier of the dispute.
        dispute_stage:
          $ref: '#/components/schemas/DisputeStage'
          description: The current stage of the dispute process.
        dispute_status:
          $ref: '#/components/schemas/DisputeStatus'
          description: The current status of the dispute.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the dispute.
        remarks:
          type:
            - string
            - 'null'
          description: Remarks
    DisputeStage:
      type: string
      enum:
        - pre_dispute
        - dispute
        - pre_arbitration
    DisputeStatus:
      type: string
      enum:
        - dispute_opened
        - dispute_expired
        - dispute_accepted
        - dispute_cancelled
        - dispute_challenged
        - dispute_won
        - dispute_lost
    Event:
      type: object
      required:
        - event_id
        - business_id
        - customer_id
        - event_name
        - timestamp
      properties:
        business_id:
          type: string
        customer_id:
          type: string
        event_id:
          type: string
        event_name:
          type: string
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/EventMetadata'
        timestamp:
          type: string
          format: date-time
    EventInput:
      type: object
      required:
        - event_id
        - customer_id
        - event_name
      properties:
        customer_id:
          type: string
          description: customer_id of the customer whose usage needs to be tracked
        event_id:
          type: string
          description: >-
            Event Id acts as an idempotency key. Any subsequent requests with the same event_id will be
            ignored
        event_name:
          type: string
          description: Name of the event
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/EventMetadata'
              description: >-
                Custom metadata. Only key value pairs are accepted, objects or arrays submitted will be
                rejected.
        timestamp:
          type:
            - string
            - 'null'
          format: date-time
          description: |-
            Custom Timestamp. Defaults to current timestamp in UTC.
            Timestamps that are older that 1 hour or after 5 mins, from current timestamp, will be rejected.
    EventMetadata:
      type: object
      additionalProperties: {}
      propertyNames:
        type: string
    EventType:
      type: string
      description: Event types for Dodo events
      enum:
        - payment.succeeded
        - payment.failed
        - payment.processing
        - payment.cancelled
        - refund.succeeded
        - refund.failed
        - dispute.opened
        - dispute.expired
        - dispute.accepted
        - dispute.cancelled
        - dispute.challenged
        - dispute.won
        - dispute.lost
        - subscription.active
        - subscription.renewed
        - subscription.on_hold
        - subscription.cancelled
        - subscription.failed
        - subscription.expired
        - subscription.plan_changed
        - license_key.created
    FailedEvent:
      type: object
      required:
        - event_id
        - error
      properties:
        error:
          type: string
        event_id:
          type: string
    FilterOperator:
      type: string
      enum:
        - equals
        - not_equals
        - greater_than
        - greater_than_or_equals
        - less_than
        - less_than_or_equals
        - contains
        - does_not_contain
    FilterType:
      oneOf:
        - type: array
          title: Direct Filter Conditions
          items:
            type: object
            title: MeterFilterCondition
            description: Filter condition with key, operator, and value
            required:
              - key
              - operator
              - value
            properties:
              key:
                type: string
                description: Filter key to apply
                maxLength: 100
                minLength: 1
              operator:
                $ref: '#/components/schemas/FilterOperator'
              value:
                oneOf:
                  - type: string
                  - type: number
                  - type: boolean
                title: Filter Value
                description: Filter value - can be string, number, or boolean
          description: Direct filter conditions - array of condition objects with key, operator, and value
          maxItems: 10
          minItems: 1
        - type: array
          title: Nested Meter Filters
          items:
            type: object
            title: MeterFilter
            description: Level 1 nested filter - can contain Level 2 filters
            required:
              - conjunction
              - clauses
            properties:
              clauses:
                oneOf:
                  - type: array
                    title: Level 1 Filter Conditions
                    items:
                      type: object
                      title: MeterFilterCondition
                      description: Filter condition with key, operator, and value
                      required:
                        - key
                        - operator
                        - value
                      properties:
                        key:
                          type: string
                          description: Filter key to apply
                          maxLength: 100
                          minLength: 1
                        operator:
                          $ref: '#/components/schemas/FilterOperator'
                        value:
                          oneOf:
                            - type: string
                            - type: number
                            - type: boolean
                          title: Filter Value
                          description: Filter value - can be string, number, or boolean
                    description: Array of filter conditions
                  - type: array
                    title: Level 1 Nested Filters
                    items:
                      type: object
                      title: MeterFilter
                      description: Level 2 nested filter
                      required:
                        - conjunction
                        - clauses
                      properties:
                        clauses:
                          oneOf:
                            - type: array
                              title: Level 2 Filter Conditions
                              items:
                                type: object
                                title: MeterFilterCondition
                                description: Filter condition with key, operator, and value
                                required:
                                  - key
                                  - operator
                                  - value
                                properties:
                                  key:
                                    type: string
                                    description: Filter key to apply
                                    maxLength: 100
                                    minLength: 1
                                  operator:
                                    $ref: '#/components/schemas/FilterOperator'
                                  value:
                                    oneOf:
                                      - type: string
                                      - type: number
                                      - type: boolean
                                    title: Filter Value
                                    description: Filter value - can be string, number, or boolean
                              description: Array of filter conditions
                            - type: array
                              title: Level 2 Nested Filters
                              items:
                                type: object
                                title: MeterFilter
                                description: Level 3 nested filter (final nesting level)
                                required:
                                  - conjunction
                                  - clauses
                                properties:
                                  clauses:
                                    type: array
                                    title: Level 3 Filter Conditions
                                    items:
                                      type: object
                                      title: MeterFilterCondition
                                      description: Filter condition with key, operator, and value
                                      required:
                                        - key
                                        - operator
                                        - value
                                      properties:
                                        key:
                                          type: string
                                          description: Filter key to apply
                                          maxLength: 100
                                          minLength: 1
                                        operator:
                                          $ref: '#/components/schemas/FilterOperator'
                                        value:
                                          oneOf:
                                            - type: string
                                            - type: number
                                            - type: boolean
                                          title: Filter Value
                                          description: Filter value - can be string, number, or boolean
                                    description: 'Level 3: Filter conditions only (max depth reached)'
                                    maxItems: 10
                                    minItems: 1
                                  conjunction:
                                    $ref: '#/components/schemas/Conjunction'
                              description: Array of level 3 nested filters (final level)
                          title: Level 2 Clause
                          description: 'Level 2: Can be conditions or nested filters (1 more level allowed)'
                        conjunction:
                          $ref: '#/components/schemas/Conjunction'
                    description: Array of level 2 nested filters
                title: Level 1 Clause
                description: 'Level 1: Can be conditions or nested filters (2 more levels allowed)'
              conjunction:
                $ref: '#/components/schemas/Conjunction'
          description: Nested filters - supports up to 3 levels deep
          maxItems: 10
          minItems: 1
      title: FilterType
      description: 'Filter type - supports up to 3 levels of nesting (Level 1: conditions or Level 2 filters)'
    GetCustomersListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/CustomerResponse'
    GetDiscountsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/DiscountResponse'
          description: Array of active (non-deleted) discounts for the current page.
    GetDisputeResponse:
      type: object
      required:
        - dispute_id
        - payment_id
        - business_id
        - amount
        - currency
        - dispute_status
        - dispute_stage
        - created_at
        - customer
      properties:
        amount:
          type: string
          description: The amount involved in the dispute, represented as a string to accommodate precision.
        business_id:
          type: string
          description: The unique identifier of the business involved in the dispute.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the dispute was created, in UTC.
        currency:
          type: string
          description: The currency of the disputed amount, represented as an ISO 4217 currency code.
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: The customer who filed the dispute
        dispute_id:
          type: string
          description: The unique identifier of the dispute.
        dispute_stage:
          $ref: '#/components/schemas/DisputeStage'
          description: The current stage of the dispute process.
        dispute_status:
          $ref: '#/components/schemas/DisputeStatus'
          description: The current status of the dispute.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the dispute.
        reason:
          type:
            - string
            - 'null'
          description: Reason for the dispute
        remarks:
          type:
            - string
            - 'null'
          description: Remarks
    GetDisputesListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/ListDisputeResponse'
    GetEventsQuery:
      type: object
      properties:
        customer_id:
          type:
            - string
            - 'null'
          description: Filter events by customer ID
        end:
          type:
            - string
            - 'null'
          format: date-time
          description: Filter events created before this timestamp
        event_name:
          type:
            - string
            - 'null'
          description: >-
            Filter events by event name. If both event_name and meter_id are provided, they must match the
            meter's configured event_name
        meter_id:
          type:
            - string
            - 'null'
          description: >-
            Filter events by meter ID. When provided, only events that match the meter's event_name and filter
            criteria will be returned
        page_number:
          type:
            - integer
            - 'null'
          format: int32
          description: 'Page number (0-based, default: 0)'
          minimum: 0
        page_size:
          type:
            - integer
            - 'null'
          format: int32
          description: 'Number of events to return per page (default: 10)'
          minimum: 0
        start:
          type:
            - string
            - 'null'
          format: date-time
          description: Filter events created after this timestamp
    GetEventsResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/Event'
    GetPaymentsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/GetPaymentsListResponseItem'
    GetPaymentsListResponseItem:
      type: object
      required:
        - payment_id
        - total_amount
        - currency
        - customer
        - created_at
        - brand_id
        - digital_products_delivered
        - metadata
      properties:
        brand_id:
          type: string
        created_at:
          type: string
          format: date-time
        currency:
          $ref: '#/components/schemas/Currency'
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
        digital_products_delivered:
          type: boolean
        metadata:
          $ref: '#/components/schemas/Metadata'
        payment_id:
          type: string
        payment_method:
          type:
            - string
            - 'null'
        payment_method_type:
          type:
            - string
            - 'null'
        status:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/IntentStatus'
        subscription_id:
          type:
            - string
            - 'null'
        total_amount:
          type: integer
          format: int32
    GetPayoutsResponseList:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/PayoutsResponse'
    GetProductResponse:
      type: object
      required:
        - product_id
        - business_id
        - created_at
        - updated_at
        - is_recurring
        - tax_category
        - price
        - license_key_enabled
        - brand_id
        - metadata
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            type: string
          description: Available Addons for subscription products
        brand_id:
          type: string
        business_id:
          type: string
          description: Unique identifier for the business to which the product belongs.
        created_at:
          type: string
          format: date-time
          description: Timestamp when the product was created.
        description:
          type:
            - string
            - 'null'
          description: Description of the product, optional.
        digital_product_delivery:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/DigitalProductDelivery'
        image:
          type:
            - string
            - 'null'
          description: URL of the product image, optional.
        is_recurring:
          type: boolean
          description: Indicates if the product is recurring (e.g., subscriptions).
        license_key_activation_message:
          type:
            - string
            - 'null'
          description: Message sent upon license key activation, if applicable.
        license_key_activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: Limit on the number of activations for the license key, if enabled.
        license_key_duration:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/LicenseKeyDuration'
              description: Duration of the license key validity, if enabled.
        license_key_enabled:
          type: boolean
          description: Indicates whether the product requires a license key.
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the product
        name:
          type:
            - string
            - 'null'
          description: Name of the product, optional.
        price:
          $ref: '#/components/schemas/Price'
          description: Pricing information for the product.
        product_id:
          type: string
          description: Unique identifier for the product.
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category associated with the product.
        updated_at:
          type: string
          format: date-time
          description: Timestamp when the product was last updated.
    GetProductsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/GetProductsListResponseItem'
    GetProductsListResponseItem:
      type: object
      required:
        - product_id
        - business_id
        - created_at
        - updated_at
        - is_recurring
        - tax_category
        - metadata
      properties:
        business_id:
          type: string
          description: Unique identifier for the business to which the product belongs.
        created_at:
          type: string
          format: date-time
          description: Timestamp when the product was created.
        currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: Currency of the price
        description:
          type:
            - string
            - 'null'
          description: Description of the product, optional.
        image:
          type:
            - string
            - 'null'
          description: URL of the product image, optional.
        is_recurring:
          type: boolean
          description: Indicates if the product is recurring (e.g., subscriptions).
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the product
        name:
          type:
            - string
            - 'null'
          description: Name of the product, optional.
        price:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Price of the product, optional.

            The price is represented in the lowest denomination of the currency.
            For example:
            - In USD, a price of `$12.34` would be represented as `1234` (cents).
            - In JPY, a price of `1500` would be represented as `1500` (yen).
            - In INR, a price of `1234.56` would be represented as `123456` (paise).

            This ensures precision and avoids floating-point rounding errors.
        price_detail:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Price'
              description: Details of the price
        product_id:
          type: string
          description: Unique identifier for the product.
        tax_category:
          $ref: '#/components/schemas/TaxCategory'
          description: Tax category associated with the product.
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive
        updated_at:
          type: string
          format: date-time
          description: Timestamp when the product was last updated.
    GetRefundsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/RefundResponse'
    GetSubscriptionsListResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/SubscriptionListResponseItem'
    GetWebhookHeadersResponse:
      type: object
      description: |-
        The value of the headers is returned in the `headers` field.

        Sensitive headers that have been redacted are returned in the sensitive
        field.
      required:
        - headers
        - sensitive
      properties:
        headers:
          type: object
          description: List of headers configured
          additionalProperties:
            type: string
          propertyNames:
            type: string
        sensitive:
          type: array
          items:
            type: string
          description: Sensitive headers without the value
    GetWebhookSecretResponse:
      type: object
      required:
        - secret
      properties:
        secret:
          type: string
    IngestEventsRequest:
      type: object
      required:
        - events
      properties:
        events:
          type: array
          items:
            $ref: '#/components/schemas/EventInput'
          description: List of events to be pushed
          maxItems: 1000
          minItems: 1
    IngestEventsResponse:
      type: object
      required:
        - ingested_count
      properties:
        ingested_count:
          type: integer
          minimum: 0
    IntentStatus:
      type: string
      enum:
        - succeeded
        - failed
        - cancelled
        - processing
        - requires_customer_action
        - requires_merchant_action
        - requires_payment_method
        - requires_confirmation
        - requires_capture
        - partially_captured
        - partially_captured_and_capturable
    LicenseKeyDuration:
      type: object
      title: License Key Duration
      required:
        - count
        - interval
      properties:
        count:
          type: integer
          format: int32
        interval:
          $ref: '#/components/schemas/TimeInterval'
    LicenseKeyInstanceResponse:
      type: object
      required:
        - id
        - business_id
        - name
        - license_key_id
        - created_at
      properties:
        business_id:
          type: string
        created_at:
          type: string
          format: date-time
          example: '2024-01-01T00:00:00Z'
        id:
          type: string
          example: lki_123
        license_key_id:
          type: string
          example: lic_123
        name:
          type: string
          example: Production Server 1
    LicenseKeyResponse:
      type: object
      required:
        - id
        - business_id
        - key
        - status
        - customer_id
        - product_id
        - payment_id
        - instances_count
        - created_at
      properties:
        activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: The maximum number of activations allowed for this license key.
          example: 5
        business_id:
          type: string
          description: The unique identifier of the business associated with the license key.
        created_at:
          type: string
          format: date-time
          description: The timestamp indicating when the license key was created, in UTC.
          example: '2024-01-01T00:00:00Z'
        customer_id:
          type: string
          description: The unique identifier of the customer associated with the license key.
          example: cus_123
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: The timestamp indicating when the license key expires, in UTC.
          example: '2024-12-31T23:59:59Z'
        id:
          type: string
          description: The unique identifier of the license key.
          example: lic_123
        instances_count:
          type: integer
          format: int32
          description: The current number of instances activated for this license key.
        key:
          type: string
          description: The license key string.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the license key.
        product_id:
          type: string
          description: The unique identifier of the product associated with the license key.
        status:
          $ref: '#/components/schemas/LicenseKeyStatus'
          description: The current status of the license key (e.g., active, inactive, expired).
        subscription_id:
          type:
            - string
            - 'null'
          description: The unique identifier of the subscription associated with the license key, if any.
    LicenseKeyStatus:
      type: string
      enum:
        - active
        - expired
        - disabled
    ListBrandsResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/BrandResponse'
          description: List of brands for this business
    ListDisputeResponse:
      type: object
      required:
        - dispute_id
        - payment_id
        - business_id
        - amount
        - currency
        - dispute_status
        - dispute_stage
        - created_at
      properties:
        amount:
          type: string
          description: The amount involved in the dispute, represented as a string to accommodate precision.
        business_id:
          type: string
          description: The unique identifier of the business involved in the dispute.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the dispute was created, in UTC.
        currency:
          type: string
          description: The currency of the disputed amount, represented as an ISO 4217 currency code.
        dispute_id:
          type: string
          description: The unique identifier of the dispute.
        dispute_stage:
          $ref: '#/components/schemas/DisputeStage'
          description: The current stage of the dispute process.
        dispute_status:
          $ref: '#/components/schemas/DisputeStatus'
          description: The current status of the dispute.
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the dispute.
    ListLicenseKeyInstancesResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/LicenseKeyInstanceResponse'
    ListLicenseKeysResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/LicenseKeyResponse'
    ListMetersResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/MeterResponse'
    ListUsageHistoryQueryParams:
      type: object
      properties:
        end_date:
          type:
            - string
            - 'null'
          format: date-time
          description: Filter by end date (inclusive)
        meter_id:
          type:
            - string
            - 'null'
          description: Filter by specific meter ID
        page_number:
          type:
            - integer
            - 'null'
          format: int32
          description: 'Page number (default: 0)'
          minimum: 0
        page_size:
          type:
            - integer
            - 'null'
          format: int32
          description: 'Page size (default: 10, max: 100)'
          minimum: 0
        start_date:
          type:
            - string
            - 'null'
          format: date-time
          description: Filter by start date (inclusive)
    ListUsageHistoryResponse:
      type: object
      required:
        - items
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/UsageHistoryItem'
          description: List of usage history items
    ListWebhooksResponse:
      type: object
      required:
        - data
        - done
      properties:
        data:
          type: array
          items:
            $ref: '#/components/schemas/WebhookDetails'
          description: List of webhoooks
        done:
          type: boolean
          description: true if no more values are to be fetched.
        iterator:
          type:
            - string
            - 'null'
          description: Cursor pointing to the next paginated object
        prev_iterator:
          type:
            - string
            - 'null'
          description: Cursor pointing to the previous paginated object
    Metadata:
      type: object
      additionalProperties:
        type: string
      propertyNames:
        type: string
    MeterAggregation:
      type: object
      title: Meter Aggregation
      required:
        - type
      properties:
        key:
          type:
            - string
            - 'null'
          description: Required when type is not COUNT
        type:
          $ref: '#/components/schemas/AggregationType'
          description: Aggregation type for the meter
    MeterFilter:
      type: object
      title: Meter Filter
      description: >-
        A filter structure that combines multiple conditions with logical conjunctions (AND/OR).


        Supports up to 3 levels of nesting to create complex filter expressions.

        Each filter has a conjunction (and/or) and clauses that can be either direct conditions or nested
        filters.
      required:
        - conjunction
        - clauses
      properties:
        clauses:
          $ref: '#/components/schemas/FilterType'
          description: Filter clauses - can be direct conditions or nested filters (up to 3 levels deep)
        conjunction:
          $ref: '#/components/schemas/Conjunction'
          description: Logical conjunction to apply between clauses (and/or)
      examples:
        - clauses:
            - key: user_id
              operator: equals
              value: user123
            - key: amount
              operator: greater_than
              value: 100
          conjunction: and
        - clauses:
            - key: plan
              operator: equals
              value: premium
            - key: plan
              operator: equals
              value: enterprise
          conjunction: or
        - clauses:
            - clauses:
                - key: user_type
                  operator: equals
                  value: premium
                - key: user_type
                  operator: equals
                  value: enterprise
              conjunction: or
            - key: active
              operator: equals
              value: true
          conjunction: and
    MeterResponse:
      type: object
      required:
        - id
        - business_id
        - name
        - event_name
        - aggregation
        - measurement_unit
        - created_at
        - updated_at
      properties:
        aggregation:
          $ref: '#/components/schemas/MeterAggregation'
        business_id:
          type: string
        created_at:
          type: string
          format: date-time
        description:
          type:
            - string
            - 'null'
        event_name:
          type: string
        filter:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/MeterFilter'
        id:
          type: string
        measurement_unit:
          type: string
        name:
          type: string
        updated_at:
          type: string
          format: date-time
    MeterUsageItem:
      type: object
      required:
        - id
        - name
        - free_threshold
        - price_per_unit
        - currency
        - total_price
        - consumed_units
        - chargeable_units
      properties:
        chargeable_units:
          type: string
          description: Chargeable units (after free threshold) as string for precision
        consumed_units:
          type: string
          description: Total units consumed as string for precision
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency for the price per unit
        free_threshold:
          type: integer
          format: int64
          description: Free threshold units for this meter
        id:
          type: string
          description: Meter identifier
        name:
          type: string
          description: Meter name
        price_per_unit:
          type: string
          description: Price per unit in string format for precision
        total_price:
          type: integer
          format: int32
          description: Total price charged for this meter in smallest currency unit (cents)
    NewCustomer:
      type: object
      title: New Customer
      required:
        - name
        - email
      properties:
        email:
          type: string
        name:
          type: string
        phone_number:
          type:
            - string
            - 'null'
    OnDemandSubscriptionReq:
      type: object
      title: On Demand Subscription Request
      required:
        - mandate_only
      properties:
        adaptive_currency_fees_inclusive:
          type:
            - boolean
            - 'null'
          description: >-
            Whether adaptive currency fees should be included in the product_price (true) or added on top
            (false).

            This field is ignored if adaptive pricing is not enabled for the business.
        mandate_only:
          type: boolean
          description: >-
            If set as True, does not perform any charge and only authorizes payment method details for future
            use.
        product_currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: >-
                Optional currency of the product price. If not specified, defaults to the currency of the
                product.
        product_description:
          type:
            - string
            - 'null'
          description: |-
            Optional product description override for billing and line items.
            If not specified, the stored description of the product will be used.
        product_price:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Product price for the initial charge to customer
            If not specified the stored price of the product will be used
            Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
    OneTimePrice:
      type: object
      title: One Time Price
      required:
        - price
        - currency
        - discount
        - purchasing_power_parity
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency in which the payment is made.
        discount:
          type: integer
          format: int64
          description: Discount applied to the price, represented as a percentage (0 to 100).
        pay_what_you_want:
          type: boolean
          description: |-
            Indicates whether the customer can pay any amount they choose.
            If set to `true`, the [`price`](Self::price) field is the minimum amount.
        price:
          type: integer
          format: int32
          description: |-
            The payment amount, in the smallest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.

            If [`pay_what_you_want`](Self::pay_what_you_want) is set to `true`, this field represents
            the **minimum** amount the customer must pay.
        purchasing_power_parity:
          type: boolean
          description: |-
            Indicates if purchasing power parity adjustments are applied to the price.
            Purchasing power parity feature is not available as of now.
        suggested_price:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            A suggested price for the user to pay. This value is only considered if
            [`pay_what_you_want`](Self::pay_what_you_want) is `true`. Otherwise, it is ignored.
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive.
    OneTimeProductCartItemReq:
      type: object
      title: One-Time Product Cart Item
      required:
        - product_id
        - quantity
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Amount the customer pays if pay_what_you_want is enabled. If disabled then amount will be ignored
            Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
        product_id:
          type: string
        quantity:
          type: integer
          format: int32
          minimum: 0
    OneTimeProductCartItemResponse:
      type: object
      title: One-Time Product Cart Item Response
      required:
        - product_id
        - quantity
      properties:
        product_id:
          type: string
        quantity:
          type: integer
          format: int32
          minimum: 0
    OutgoingWebhook:
      type: object
      required:
        - business_id
        - type
        - timestamp
        - data
      properties:
        business_id:
          type: string
        data:
          $ref: '#/components/schemas/OutgoingWebhookData'
          description: The latest data at the time of delivery attempt
        timestamp:
          type: string
          format: date-time
          description: The timestamp of when the event occurred (not necessarily the same of when it was delivered)
        type:
          $ref: '#/components/schemas/EventType'
    OutgoingWebhookData:
      oneOf:
        - allOf:
            - $ref: '#/components/schemas/PaymentResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Payment
          title: Payment
        - allOf:
            - $ref: '#/components/schemas/SubscriptionResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Subscription
          title: Subscription
        - allOf:
            - $ref: '#/components/schemas/RefundResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Refund
          title: Refund
        - allOf:
            - $ref: '#/components/schemas/GetDisputeResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - Dispute
          title: Dispute
        - allOf:
            - $ref: '#/components/schemas/LicenseKeyResponse'
            - type: object
              required:
                - payload_type
              properties:
                payload_type:
                  type: string
                  enum:
                    - LicenseKey
          title: License Key
    PartialRefundItem:
      type: object
      required:
        - item_id
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: The amount to refund. if None the whole item is refunded
        item_id:
          type: string
          description: The id of the item (i.e. `product_id` or `addon_id`)
        tax_inclusive:
          type: boolean
          description: Specify if tax is inclusive of the refund. Default true.
    PatchAddonRequest:
      type: object
      properties:
        currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: The currency of the Addon
        description:
          type:
            - string
            - 'null'
          description: Description of the Addon, optional and must be at most 1000 characters.
        image_id:
          type:
            - string
            - 'null'
          format: uuid
          description: Addon image id after its uploaded to S3
        name:
          type:
            - string
            - 'null'
          description: Name of the Addon, optional and must be at most 100 characters.
        price:
          type:
            - integer
            - 'null'
          format: int32
          description: Amount of the addon
        tax_category:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/TaxCategory'
              description: Tax category of the Addon.
    PatchBrandRequest:
      type: object
      properties:
        image_id:
          type:
            - string
            - 'null'
          format: uuid
          description: The UUID you got back from the presignedupload call
        name:
          type:
            - string
            - 'null'
        statement_descriptor:
          type:
            - string
            - 'null'
        support_email:
          type:
            - string
            - 'null'
    PatchCustomerRequest:
      type: object
      properties:
        name:
          type:
            - string
            - 'null'
        phone_number:
          type:
            - string
            - 'null'
    PatchDigitalProductDeliveryRequest:
      type: object
      title: Patch Digital Product Delivery Request
      properties:
        external_url:
          type:
            - string
            - 'null'
          description: External URL to digital product
        files:
          type:
            - array
            - 'null'
          items:
            type: string
            format: uuid
          description: Uploaded files ids of digital product
        instructions:
          type:
            - string
            - 'null'
          description: Instructions to download and use the digital product
    PatchDiscountRequest:
      type: object
      description: |-
        Request body for patching (updating) a discount.

        All fields are optional and only update if provided.
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            If present, update the discount amount:
            - If `discount_type` is `percentage`, this represents **basis points** (e.g., `540` = `5.4%`).
            - Otherwise, this represents **USD cents** (e.g., `100` = `$1.00`).

            Must be at least 1 if provided.
        code:
          type:
            - string
            - 'null'
          description: If present, update the discount code (uppercase).
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
        name:
          type:
            - string
            - 'null'
        restricted_to:
          type:
            - array
            - 'null'
          items:
            type: string
          description: |-
            If present, replaces all restricted product IDs with this new set.
            To remove all restrictions, send empty array
        subscription_cycles:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Number of subscription billing cycles this discount is valid for.
            If not provided, the discount will be applied indefinitely to
            all recurring payments related to the subscription.
        type:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/DiscountType'
              description: If present, update the discount type.
        usage_limit:
          type:
            - integer
            - 'null'
          format: int32
    PatchLicenseKeyInstanceRequest:
      type: object
      required:
        - name
      properties:
        name:
          type: string
    PatchLicenseKeyRequest:
      type: object
      properties:
        activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            The updated activation limit for the license key.
            Use `null` to remove the limit, or omit this field to leave it unchanged.
        disabled:
          type:
            - boolean
            - 'null'
          description: >-
            Indicates whether the license key should be disabled.

            A value of `true` disables the key, while `false` enables it. Omit this field to leave it
            unchanged.
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: |-
            The updated expiration timestamp for the license key in UTC.
            Use `null` to remove the expiration date, or omit this field to leave it unchanged.
    PatchProductRequest:
      type: object
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            type: string
          description: Available Addons for subscription products
        brand_id:
          type:
            - string
            - 'null'
        description:
          type:
            - string
            - 'null'
          description: Description of the product, optional and must be at most 1000 characters.
        digital_product_delivery:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/PatchDigitalProductDeliveryRequest'
              description: Choose how you would like you digital product delivered
        image_id:
          type:
            - string
            - 'null'
          format: uuid
          description: Product image id after its uploaded to S3
        license_key_activation_message:
          type:
            - string
            - 'null'
          description: |-
            Message sent to the customer upon license key activation.

            Only applicable if `license_key_enabled` is `true`. This message contains instructions for
            activating the license key.
        license_key_activations_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Limit for the number of activations for the license key.

            Only applicable if `license_key_enabled` is `true`. Represents the maximum number of times
            the license key can be activated.
        license_key_duration:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/LicenseKeyDuration'
              description: |-
                Duration of the license key if enabled.

                Only applicable if `license_key_enabled` is `true`. Represents the duration in days for which
                the license key is valid.
        license_key_enabled:
          type:
            - boolean
            - 'null'
          description: >-
            Whether the product requires a license key.


            If `true`, additional fields related to license key (duration, activations limit, activation
            message)

            become applicable.
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Metadata'
              description: Additional metadata for the product
        name:
          type:
            - string
            - 'null'
          description: Name of the product, optional and must be at most 100 characters.
        price:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Price'
              description: Price details of the product.
        tax_category:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/TaxCategory'
              description: Tax category of the product.
    PatchSubscriptionRequest:
      type: object
      properties:
        billing:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/BillingAddress'
        cancel_at_next_billing_date:
          type:
            - boolean
            - 'null'
          description: When set, the subscription will remain active until the end of billing period
        disable_on_demand:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/DisableOnDemandReq'
        metadata:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Metadata'
        next_billing_date:
          type:
            - string
            - 'null'
          format: date-time
        status:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/SubscriptionStatus'
        tax_id:
          type:
            - string
            - 'null'
    PatchWebhookRequest:
      type: object
      properties:
        description:
          type:
            - string
            - 'null'
          description: Description of the webhook
        disabled:
          type:
            - boolean
            - 'null'
          description: To Disable the endpoint, set it to true.
        filter_types:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/EventType'
          description: |-
            Filter events to the endpoint.

            Webhook event will only be sent for events in the list.
        metadata:
          type:
            - object
            - 'null'
          description: Metadata
          additionalProperties:
            type: string
          propertyNames:
            type: string
        rate_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: Rate limit
          minimum: 0
        url:
          type:
            - string
            - 'null'
          description: Url endpoint
    PaymentLineItem:
      type: object
      required:
        - items_id
        - amount
        - tax
        - refundable_amount
      properties:
        amount:
          type: integer
          format: int32
        description:
          type:
            - string
            - 'null'
        items_id:
          type: string
        name:
          type:
            - string
            - 'null'
        refundable_amount:
          type: integer
          format: int32
        tax:
          type: integer
          format: int32
    PaymentLineItemsResponse:
      type: object
      required:
        - currency
        - items
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
        items:
          type: array
          items:
            $ref: '#/components/schemas/PaymentLineItem'
    PaymentMethodTypes:
      type: string
      enum:
        - credit
        - debit
        - upi_collect
        - upi_intent
        - apple_pay
        - cashapp
        - google_pay
        - multibanco
        - bancontact_card
        - eps
        - ideal
        - przelewy24
        - affirm
        - klarna
        - sepa
        - ach
        - amazon_pay
        - afterpay_clearpay
    PaymentResponse:
      type: object
      required:
        - payment_id
        - business_id
        - total_amount
        - currency
        - created_at
        - disputes
        - refunds
        - customer
        - metadata
        - settlement_amount
        - settlement_currency
        - billing
        - brand_id
        - digital_products_delivered
      properties:
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for payments
        brand_id:
          type: string
          description: brand id this payment belongs to
        business_id:
          type: string
          description: Identifier of the business associated with the payment
        card_issuing_country:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/CountryCodeAlpha2'
              description: ISO2 country code of the card
        card_last_four:
          type:
            - string
            - 'null'
          description: The last four digits of the card
        card_network:
          type:
            - string
            - 'null'
          description: Card network like VISA, MASTERCARD etc.
        card_type:
          type:
            - string
            - 'null'
          description: The type of card DEBIT or CREDIT
        created_at:
          type: string
          format: date-time
          description: Timestamp when the payment was created
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency used for the payment
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Details about the customer who made the payment
        digital_products_delivered:
          type: boolean
          description: brand id this payment belongs to
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        disputes:
          type: array
          items:
            $ref: '#/components/schemas/DisputeResponse'
          description: List of disputes associated with this payment
        error_code:
          type:
            - string
            - 'null'
          description: An error code if the payment failed
        error_message:
          type:
            - string
            - 'null'
          description: An error message if the payment failed
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the payment
        payment_id:
          type: string
          description: Unique identifier for the payment
        payment_link:
          type:
            - string
            - 'null'
          description: Checkout URL
        payment_method:
          type:
            - string
            - 'null'
          description: Payment method used by customer (e.g. "card", "bank_transfer")
        payment_method_type:
          type:
            - string
            - 'null'
          description: Specific type of payment method (e.g. "visa", "mastercard")
        product_cart:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/OneTimeProductCartItemResponse'
          description: List of products purchased in a one-time payment
        refunds:
          type: array
          items:
            $ref: '#/components/schemas/RefundResponse'
          description: List of refunds issued for this payment
        settlement_amount:
          type: integer
          format: int32
          description: >-
            The amount that will be credited to your Dodo balance after currency conversion and processing.

            Especially relevant for adaptive pricing where the customer's payment currency differs from your
            settlement currency.
        settlement_currency:
          $ref: '#/components/schemas/Currency'
          description: |-
            The currency in which the settlement_amount will be credited to your Dodo balance.
            This may differ from the customer's payment currency in adaptive pricing scenarios.
        settlement_tax:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            This represents the portion of settlement_amount that corresponds to taxes collected.
            Especially relevant for adaptive pricing where the tax component must be tracked separately
            in your Dodo balance.
        status:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/IntentStatus'
              description: Current status of the payment intent
        subscription_id:
          type:
            - string
            - 'null'
          description: Identifier of the subscription if payment is part of a subscription
        tax:
          type:
            - integer
            - 'null'
          format: int32
          description: Amount of tax collected in smallest currency unit (e.g. cents)
        total_amount:
          type: integer
          format: int32
          description: Total amount charged to the customer including tax, in smallest currency unit (e.g. cents)
        updated_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Timestamp when the payment was last updated
    PayoutStatus:
      type: string
      enum:
        - not_initiated
        - in_progress
        - on_hold
        - failed
        - success
    PayoutsResponse:
      type: object
      required:
        - payout_id
        - business_id
        - payment_method
        - status
        - fee
        - tax
        - amount
        - created_at
        - updated_at
        - currency
        - refunds
        - chargebacks
      properties:
        amount:
          type: integer
          format: int64
          description: The total amount of the payout.
        business_id:
          type: string
          description: The unique identifier of the business associated with the payout.
        chargebacks:
          type: integer
          format: int64
          description: The total value of chargebacks associated with the payout.
        created_at:
          type: string
          format: date-time
          description: The timestamp when the payout was created, in UTC.
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency of the payout, represented as an ISO 4217 currency code.
        fee:
          type: integer
          format: int64
          description: The fee charged for processing the payout.
        name:
          type:
            - string
            - 'null'
          description: The name of the payout recipient or purpose.
        payment_method:
          type: string
          description: The payment method used for the payout (e.g., bank transfer, card, etc.).
        payout_document_url:
          type:
            - string
            - 'null'
          description: The URL of the document associated with the payout.
        payout_id:
          type: string
          description: The unique identifier of the payout.
        refunds:
          type: integer
          format: int64
          description: The total value of refunds associated with the payout.
        remarks:
          type:
            - string
            - 'null'
          description: Any additional remarks or notes associated with the payout.
        status:
          $ref: '#/components/schemas/PayoutStatus'
          description: The current status of the payout.
        tax:
          type: integer
          format: int64
          description: The tax applied to the payout.
        updated_at:
          type: string
          format: date-time
          description: The timestamp when the payout was last updated, in UTC.
    Price:
      oneOf:
        - allOf:
            - $ref: '#/components/schemas/OneTimePrice'
              description: One-time price details.
            - type: object
              required:
                - type
              properties:
                type:
                  type: string
                  enum:
                    - one_time_price
          title: One Time Price
          description: One-time price details.
        - allOf:
            - $ref: '#/components/schemas/RecurringPrice'
              description: Recurring price details.
            - type: object
              required:
                - type
              properties:
                type:
                  type: string
                  enum:
                    - recurring_price
          title: Recurring Price
          description: Recurring price details.
        - allOf:
            - $ref: '#/components/schemas/UsageBasedPrice'
              description: Usage Based price details.
            - type: object
              required:
                - type
              properties:
                type:
                  type: string
                  enum:
                    - usage_based_price
          title: Usage Based Price
          description: Usage Based price details.
    ProductItemReq:
      type: object
      title: Product Item Request
      required:
        - product_id
        - quantity
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/AttachAddonReq'
          description: only valid if product is a subscription
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: |-
            Amount the customer pays if pay_what_you_want is enabled. If disabled then amount will be ignored
            Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
            Only applicable for one time payments

            If amount is not set for pay_what_you_want product,
            customer is allowed to select the amount.
        product_id:
          type: string
          description: unique id of the product
        quantity:
          type: integer
          format: int32
          minimum: 0
    ProrationBillingMode:
      type: string
      title: Proration Billing Mode
      enum:
        - prorated_immediately
        - full_immediately
        - difference_immediately
    RecurringPrice:
      type: object
      title: Recurring Price
      required:
        - price
        - currency
        - discount
        - purchasing_power_parity
        - payment_frequency_count
        - payment_frequency_interval
        - subscription_period_count
        - subscription_period_interval
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency in which the payment is made.
        discount:
          type: integer
          format: int64
          description: Discount applied to the price, represented as a percentage (0 to 100).
        payment_frequency_count:
          type: integer
          format: int32
          description: >-
            Number of units for the payment frequency.

            For example, a value of `1` with a `payment_frequency_interval` of `month` represents monthly
            payments.
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: The time interval for the payment frequency (e.g., day, month, year).
        price:
          type: integer
          format: int32
          description: |-
            The payment amount. Represented in the lowest denomination of the currency (e.g., cents for USD).
            For example, to charge $1.00, pass `100`.
        purchasing_power_parity:
          type: boolean
          description: |-
            Indicates if purchasing power parity adjustments are applied to the price.
            Purchasing power parity feature is not available as of now
        subscription_period_count:
          type: integer
          format: int32
          description: >-
            Number of units for the subscription period.

            For example, a value of `12` with a `subscription_period_interval` of `month` represents a
            one-year subscription.
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: The time interval for the subscription period (e.g., day, month, year).
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive
        trial_period_days:
          type: integer
          format: int32
          description: Number of days for the trial period. A value of `0` indicates no trial period.
    RefundResponse:
      type: object
      required:
        - refund_id
        - payment_id
        - business_id
        - status
        - created_at
        - is_partial
      properties:
        amount:
          type:
            - integer
            - 'null'
          format: int32
          description: The refunded amount.
        business_id:
          type: string
          description: The unique identifier of the business issuing the refund.
        created_at:
          type: string
          format: date-time
          description: The timestamp of when the refund was created in UTC.
        currency:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/Currency'
              description: The currency of the refund, represented as an ISO 4217 currency code.
        is_partial:
          type: boolean
          description: If true the refund is a partial refund
        payment_id:
          type: string
          description: The unique identifier of the payment associated with the refund.
        reason:
          type:
            - string
            - 'null'
          description: The reason provided for the refund, if any. Optional.
        refund_id:
          type: string
          description: The unique identifier of the refund.
        status:
          $ref: '#/components/schemas/RefundStatus'
          description: The current status of the refund.
    RefundStatus:
      type: string
      enum:
        - succeeded
        - failed
        - pending
        - review
    SubscriptionData:
      type: object
      title: Subscription Data
      properties:
        on_demand:
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/OnDemandSubscriptionReq'
        trial_period_days:
          type:
            - integer
            - 'null'
          format: int32
          description: >-
            Optional trial period in days If specified, this value overrides the trial period set in the
            product's price Must be between 0 and 10000 days
    SubscriptionListResponseItem:
      type: object
      description: Response struct representing subscription details
      required:
        - subscription_id
        - recurring_pre_tax_amount
        - tax_inclusive
        - currency
        - status
        - created_at
        - product_id
        - quantity
        - trial_period_days
        - subscription_period_interval
        - payment_frequency_interval
        - subscription_period_count
        - payment_frequency_count
        - next_billing_date
        - previous_billing_date
        - customer
        - metadata
        - cancel_at_next_billing_date
        - billing
        - on_demand
      properties:
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for payments
        cancel_at_next_billing_date:
          type: boolean
          description: Indicates if the subscription will cancel at the next billing date
        cancelled_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Cancelled timestamp if the subscription is cancelled
        created_at:
          type: string
          format: date-time
          description: Timestamp when the subscription was created
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency used for the subscription payments
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Customer details associated with the subscription
        discount_cycles_remaining:
          type:
            - integer
            - 'null'
          format: int32
          description: Number of remaining discount cycles if discount is applied
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the subscription
        next_billing_date:
          type: string
          format: date-time
          description: Timestamp of the next scheduled billing. Indicates the end of current billing period
        on_demand:
          type: boolean
          description: Wether the subscription is on-demand or not
        payment_frequency_count:
          type: integer
          format: int32
          description: Number of payment frequency intervals
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for payment frequency (e.g. month, year)
        previous_billing_date:
          type: string
          format: date-time
          description: Timestamp of the last payment. Indicates the start of current billing period
        product_id:
          type: string
          description: Identifier of the product associated with this subscription
        quantity:
          type: integer
          format: int32
          description: Number of units/items included in the subscription
        recurring_pre_tax_amount:
          type: integer
          format: int32
          description: Amount charged before tax for each recurring payment in smallest currency unit (e.g. cents)
        status:
          $ref: '#/components/schemas/SubscriptionStatus'
          description: Current status of the subscription
        subscription_id:
          type: string
          description: Unique identifier for the subscription
        subscription_period_count:
          type: integer
          format: int32
          description: Number of subscription period intervals
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for the subscription period (e.g. month, year)
        tax_inclusive:
          type: boolean
          description: Indicates if the recurring_pre_tax_amount is tax inclusive
        trial_period_days:
          type: integer
          format: int32
          description: Number of days in the trial period (0 if no trial)
    SubscriptionResponse:
      type: object
      description: Response struct representing subscription details
      required:
        - subscription_id
        - recurring_pre_tax_amount
        - tax_inclusive
        - currency
        - status
        - created_at
        - product_id
        - quantity
        - trial_period_days
        - subscription_period_interval
        - payment_frequency_interval
        - subscription_period_count
        - payment_frequency_count
        - next_billing_date
        - previous_billing_date
        - customer
        - metadata
        - cancel_at_next_billing_date
        - billing
        - on_demand
        - addons
      properties:
        addons:
          type: array
          items:
            $ref: '#/components/schemas/AddonCartResponseItem'
          description: Addons associated with this subscription
        billing:
          $ref: '#/components/schemas/BillingAddress'
          description: Billing address details for payments
        cancel_at_next_billing_date:
          type: boolean
          description: Indicates if the subscription will cancel at the next billing date
        cancelled_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Cancelled timestamp if the subscription is cancelled
        created_at:
          type: string
          format: date-time
          description: Timestamp when the subscription was created
        currency:
          $ref: '#/components/schemas/Currency'
          description: Currency used for the subscription payments
        customer:
          $ref: '#/components/schemas/CustomerLimitedDetailsResponse'
          description: Customer details associated with the subscription
        discount_cycles_remaining:
          type:
            - integer
            - 'null'
          format: int32
          description: Number of remaining discount cycles if discount is applied
        discount_id:
          type:
            - string
            - 'null'
          description: The discount id if discount is applied
        expires_at:
          type:
            - string
            - 'null'
          format: date-time
          description: Timestamp when the subscription will expire
        metadata:
          $ref: '#/components/schemas/Metadata'
          description: Additional custom data associated with the subscription
        next_billing_date:
          type: string
          format: date-time
          description: Timestamp of the next scheduled billing. Indicates the end of current billing period
        on_demand:
          type: boolean
          description: Wether the subscription is on-demand or not
        payment_frequency_count:
          type: integer
          format: int32
          description: Number of payment frequency intervals
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for payment frequency (e.g. month, year)
        previous_billing_date:
          type: string
          format: date-time
          description: Timestamp of the last payment. Indicates the start of current billing period
        product_id:
          type: string
          description: Identifier of the product associated with this subscription
        quantity:
          type: integer
          format: int32
          description: Number of units/items included in the subscription
        recurring_pre_tax_amount:
          type: integer
          format: int32
          description: Amount charged before tax for each recurring payment in smallest currency unit (e.g. cents)
        status:
          $ref: '#/components/schemas/SubscriptionStatus'
          description: Current status of the subscription
        subscription_id:
          type: string
          description: Unique identifier for the subscription
        subscription_period_count:
          type: integer
          format: int32
          description: Number of subscription period intervals
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: Time interval for the subscription period (e.g. month, year)
        tax_inclusive:
          type: boolean
          description: Indicates if the recurring_pre_tax_amount is tax inclusive
        trial_period_days:
          type: integer
          format: int32
          description: Number of days in the trial period (0 if no trial)
    SubscriptionStatus:
      type: string
      enum:
        - pending
        - active
        - on_hold
        - cancelled
        - failed
        - expired
    TaxCategory:
      type: string
      description: Represents the different categories of taxation applicable to various products and services.
      enum:
        - digital_products
        - saas
        - e_book
        - edtech
    TimeInterval:
      type: string
      enum:
        - Day
        - Week
        - Month
        - Year
    UpdateAddonImageResponse:
      type: object
      required:
        - url
        - image_id
      properties:
        image_id:
          type: string
          format: uuid
        url:
          type: string
    UpdateBrandImageResponse:
      type: object
      required:
        - url
        - image_id
      properties:
        image_id:
          type: string
          format: uuid
          description: UUID that will be used as the image identifier/key suffix
        url:
          type: string
          description: Presigned URL to upload the image
    UpdateProductImageResponse:
      type: object
      required:
        - url
      properties:
        image_id:
          type:
            - string
            - 'null'
          format: uuid
        url:
          type: string
    UpdateSubscriptionPlanReq:
      type: object
      required:
        - product_id
        - quantity
        - proration_billing_mode
      properties:
        addons:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/AttachAddonReq'
          description: |-
            Addons for the new plan.
            Note : Leaving this empty would remove any existing addons
        product_id:
          type: string
          description: Unique identifier of the product to subscribe to
        proration_billing_mode:
          $ref: '#/components/schemas/ProrationBillingMode'
          description: Proration Billing Mode
        quantity:
          type: integer
          format: int32
          description: Number of units to subscribe for. Must be at least 1.
          minimum: 0
    UploadProductFile:
      type: object
      required:
        - file_name
      properties:
        file_name:
          type: string
    UploadProductFileResponse:
      type: object
      required:
        - url
        - file_id
      properties:
        file_id:
          type: string
          format: uuid
        url:
          type: string
    UsageBasedPrice:
      type: object
      title: Usage Based Price
      required:
        - fixed_price
        - currency
        - discount
        - purchasing_power_parity
        - payment_frequency_count
        - payment_frequency_interval
        - subscription_period_count
        - subscription_period_interval
      properties:
        currency:
          $ref: '#/components/schemas/Currency'
          description: The currency in which the payment is made.
        discount:
          type: integer
          format: int64
          description: Discount applied to the price, represented as a percentage (0 to 100).
        fixed_price:
          type: integer
          format: int32
          description: >-
            The fixed payment amount. Represented in the lowest denomination of the currency (e.g., cents for
            USD).

            For example, to charge $1.00, pass `100`.
        meters:
          type:
            - array
            - 'null'
          items:
            $ref: '#/components/schemas/AddMeterToPrice'
        payment_frequency_count:
          type: integer
          format: int32
          description: >-
            Number of units for the payment frequency.

            For example, a value of `1` with a `payment_frequency_interval` of `month` represents monthly
            payments.
        payment_frequency_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: The time interval for the payment frequency (e.g., day, month, year).
        purchasing_power_parity:
          type: boolean
          description: |-
            Indicates if purchasing power parity adjustments are applied to the price.
            Purchasing power parity feature is not available as of now
        subscription_period_count:
          type: integer
          format: int32
          description: >-
            Number of units for the subscription period.

            For example, a value of `12` with a `subscription_period_interval` of `month` represents a
            one-year subscription.
        subscription_period_interval:
          $ref: '#/components/schemas/TimeInterval'
          description: The time interval for the subscription period (e.g., day, month, year).
        tax_inclusive:
          type:
            - boolean
            - 'null'
          description: Indicates if the price is tax inclusive
    UsageHistoryItem:
      type: object
      required:
        - start_date
        - end_date
        - meters
      properties:
        end_date:
          type: string
          format: date-time
          description: End date of the billing period
        meters:
          type: array
          items:
            $ref: '#/components/schemas/MeterUsageItem'
          description: List of meters and their usage for this billing period
        start_date:
          type: string
          format: date-time
          description: Start date of the billing period
    ValidateLicenseKeyRequest:
      type: object
      required:
        - license_key
      properties:
        license_key:
          type: string
          example: 2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43
        license_key_instance_id:
          type:
            - string
            - 'null'
          example: lki_123
    ValidateLicenseKeyResponse:
      type: object
      required:
        - valid
      properties:
        valid:
          type: boolean
          example: true
    WebhookDetails:
      type: object
      title: Webhook Details
      required:
        - description
        - id
        - metadata
        - created_at
        - updated_at
        - url
      properties:
        created_at:
          type: string
          description: Created at timestamp
        description:
          type: string
          description: An example webhook name.
        disabled:
          type:
            - boolean
            - 'null'
          description: |-
            Status of the webhook.

            If true, events are not sent
        filter_types:
          type:
            - array
            - 'null'
          items:
            type: string
          description: |-
            Filter events to the webhook.

            Webhook event will only be sent for events in the list.
        id:
          type: string
          description: The webhook's ID.
        metadata:
          type: object
          description: Metadata of the webhook
          additionalProperties:
            type: string
          propertyNames:
            type: string
        rate_limit:
          type:
            - integer
            - 'null'
          format: int32
          description: Configured rate limit
          minimum: 0
        updated_at:
          type: string
          description: Updated at timestamp
        url:
          type: string
          description: Url endpoint of the webhook
    WebhookHeadersReq:
      type: object
      title: Webhook Headers Request
      required:
        - headers
      properties:
        headers:
          type: object
          description: Object of header-value pair to update or add
          additionalProperties:
            type: string
          propertyNames:
            type: string
  securitySchemes:
    API_KEY:
      type: http
      scheme: bearer
tags:
  - name: Products
  - name: Payments
  - name: Subscriptions
  - name: Addons
  - name: Customers
  - name: Refunds
  - name: Disputes
  - name: Events
  - name: License Keys
  - name: Licenses
  - name: Discounts
  - name: Meters
  - name: Outgoing Webhooks
  - name: Checkout
  - name: Webhook Events
x-webhooks:
  dispute.accepted:
    post:
      description: Sent when a dispute is accepted
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_accepted
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.accepted
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.accepted
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute accepted webhook
  dispute.cancelled:
    post:
      description: Sent when a dispute is cancelled
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_cancelled
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.cancelled
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.cancelled
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute cancelled webhook
  dispute.challenged:
    post:
      description: Sent when a dispute is challenged
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_challenged
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.challenged
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.challenged
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute challenged webhook
  dispute.expired:
    post:
      description: Sent when a dispute expires
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_expired
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.expired
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.expired
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute expired webhook
  dispute.lost:
    post:
      description: Sent when a dispute is lost
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_lost
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.lost
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.lost
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute lost webhook
  dispute.opened:
    post:
      description: Sent when a dispute is opened
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_opened
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.opened
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.opened
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute opened webhook
  dispute.won:
    post:
      description: Sent when a dispute is won
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: '400'
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:39:56.332Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                dispute_id: dp_q9BVPKzA4HeQs2f2PmDc
                dispute_stage: dispute
                dispute_status: dispute_won
                payload_type: Dispute
                payment_id: pay_gUHcgg81JkW1sbH0zbykQ
                reason: fraudulent
                remarks: null
              timestamp: '2025-08-04T05:39:56.397297Z'
              type: dispute.won
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/DisputeResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Dispute
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - dispute.won
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Dispute won webhook
  license_key.created:
    post:
      description: Sent when a license key is created
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                activations_limit: null
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:43:19.882409Z'
                customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                expires_at: null
                id: lic_bL8HwBAMfuQKS8HODxegO
                instances_count: 0
                key: db44b22c-fe9b-4a68-bf0d-b0e0d6c6c8c0
                payload_type: LicenseKey
                payment_id: pay_E5v6dwdKJCg83Gcxd3TRA
                product_id: pdt_64iOqOi80QypjfohmrwAH
                status: active
                subscription_id: null
              timestamp: '2025-08-04T05:43:19.882409Z'
              type: license_key.created
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/LicenseKeyResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - LicenseKey
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - license_key.created
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: License key created webhook
  payment.cancelled:
    post:
      description: Sent when a payment is cancelled
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHS
              data:
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: New York, New York
                  zipcode: ' '
                brand_id: bus_P3SXLcppjXgagmHSVaH3N
                business_id: bus_P3SXLcppjXgagmHS
                card_issuing_country: US
                card_last_four: '0119'
                card_network: VISA
                card_type: CREDIT
                created_at: '2025-08-04T05:30:31.152232Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfB
                  email: test@acme.com
                  name: Test user
                digital_products_delivered: false
                discount_id: null
                disputes: []
                error_code: PROCESSING_ERROR
                error_message: An error occurred while processing your card. Try again in a little bit.
                metadata: {}
                payload_type: Payment
                payment_id: pay_2IjeQm4hqU6RA4Z4kwDee
                payment_link: https://test.checkout.dodopayments.com/cbq
                payment_method: card
                payment_method_type: null
                product_cart:
                  - product_id: pdt_e9mUw084cWnu0tz
                    quantity: 1
                refunds: []
                settlement_amount: 400
                settlement_currency: USD
                settlement_tax: null
                status: cancelled
                subscription_id: null
                tax: null
                total_amount: 400
                updated_at: null
              timestamp: '2025-08-04T05:36:41.609359Z'
              type: payment.cancelled
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/PaymentResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Payment
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - payment.cancelled
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Payment cancelled webhook
  payment.failed:
    post:
      description: Sent when a payment fails to process
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHS
              data:
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: New York, New York
                  zipcode: ' '
                brand_id: bus_P3SXLcppjXgagmHSVaH3N
                business_id: bus_P3SXLcppjXgagmHS
                card_issuing_country: US
                card_last_four: '0119'
                card_network: VISA
                card_type: CREDIT
                created_at: '2025-08-04T05:30:31.152232Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfB
                  email: test@acme.com
                  name: Test user
                digital_products_delivered: false
                discount_id: null
                disputes: []
                error_code: PROCESSING_ERROR
                error_message: An error occurred while processing your card. Try again in a little bit.
                metadata: {}
                payload_type: Payment
                payment_id: pay_2IjeQm4hqU6RA4Z4kwDee
                payment_link: https://test.checkout.dodopayments.com/cbq
                payment_method: card
                payment_method_type: null
                product_cart:
                  - product_id: pdt_e9mUw084cWnu0tz
                    quantity: 1
                refunds: []
                settlement_amount: 400
                settlement_currency: USD
                settlement_tax: null
                status: failed
                subscription_id: null
                tax: null
                total_amount: 400
                updated_at: null
              timestamp: '2025-08-04T05:36:41.609359Z'
              type: payment.failed
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/PaymentResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Payment
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - payment.failed
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Payment failed webhook
  payment.processing:
    post:
      description: Sent when a payment is being processed
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHS
              data:
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: New York, New York
                  zipcode: ' '
                brand_id: bus_P3SXLcppjXgagmHSVaH3N
                business_id: bus_P3SXLcppjXgagmHS
                card_issuing_country: US
                card_last_four: '0119'
                card_network: VISA
                card_type: CREDIT
                created_at: '2025-08-04T05:30:31.152232Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfB
                  email: test@acme.com
                  name: Test user
                digital_products_delivered: false
                discount_id: null
                disputes: []
                error_code: null
                error_message: null
                metadata: {}
                payload_type: Payment
                payment_id: pay_2IjeQm4hqU6RA4Z4kwDee
                payment_link: https://test.checkout.dodopayments.com/cbq
                payment_method: card
                payment_method_type: null
                product_cart:
                  - product_id: pdt_e9mUw084cWnu0tz
                    quantity: 1
                refunds: []
                settlement_amount: 400
                settlement_currency: USD
                settlement_tax: null
                status: processing
                subscription_id: null
                tax: null
                total_amount: 400
                updated_at: null
              timestamp: '2025-08-04T05:36:41.609359Z'
              type: payment.processing
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/PaymentResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Payment
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - payment.processing
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Payment processing webhook
  payment.succeeded:
    post:
      description: Sent when a payment is successfully processed
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHS
              data:
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: New York, New York
                  zipcode: '0'
                brand_id: bus_P3SXLcppjXgagmHS
                business_id: bus_P3SXLcppjXgagmHS
                card_issuing_country: GB
                card_last_four: '4242'
                card_network: VISA
                card_type: CREDIT
                created_at: '2025-08-04T05:30:31.152232Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfB
                  email: test@acme.com
                  name: Test user
                digital_products_delivered: false
                discount_id: null
                disputes: []
                error_code: null
                error_message: null
                metadata: {}
                payload_type: Payment
                payment_id: pay_2IjeQm4hqU6RA4Z4kwDee
                payment_link: https://test.checkout.dodopayments.com/cbq
                payment_method: card
                payment_method_type: null
                product_cart:
                  - product_id: pdt_e9mUw084cWnu0tz
                    quantity: 1
                refunds: []
                settlement_amount: 400
                settlement_currency: USD
                settlement_tax: null
                status: succeeded
                subscription_id: null
                tax: null
                total_amount: 400
                updated_at: null
              timestamp: '2025-08-04T05:30:45.182629Z'
              type: payment.succeeded
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/PaymentResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Payment
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - payment.succeeded
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Payment succeeded webhook
  refund.failed:
    post:
      description: Sent when a refund fails to process
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: 400
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:50:32.873493Z'
                currency: USD
                is_partial: false
                payload_type: Refund
                payment_id: pay_aTkzUDRuc7Rb3kVJXE17z
                reason: Testing Refund failure
                refund_id: ref_nUV0DuvmVgeKJVbS04L0y
                status: failed
              timestamp: '2025-08-04T05:50:38.661452Z'
              type: refund.failed
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/RefundResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Refund
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - refund.failed
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Refund failed webhook
  refund.succeeded:
    post:
      description: Sent when a refund is successfully processed
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_P3SXLcppjXgagmHSVaH3N
              data:
                amount: 400
                business_id: bus_P3SXLcppjXgagmHSVaH3N
                created_at: '2025-08-04T05:50:32.873493Z'
                currency: USD
                is_partial: false
                payload_type: Refund
                payment_id: pay_aTkzUDRuc7Rb3kVJXE17z
                reason: Testing success refund
                refund_id: ref_nUV0DuvmVgeKJVbS04L0y
                status: succeeded
              timestamp: '2025-08-04T05:47:49.922046Z'
              type: refund.succeeded
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/RefundResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Refund
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - refund.succeeded
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Refund succeeded webhook
  subscription.active:
    post:
      description: Sent when a subscription becomes active
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: null
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 1000
                status: active
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-08-04T05:45:31.736731Z'
              type: subscription.active
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.active
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription active webhook
  subscription.cancelled:
    post:
      description: Sent when a subscription is cancelled
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: '2025-08-04T05:48:25.139421Z'
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 1000
                status: cancelled
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-08-04T05:48:25.134643Z'
              type: subscription.cancelled
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.cancelled
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription cancelled webhook
  subscription.expired:
    post:
      description: Sent when a subscription expires
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: null
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 1000
                status: expired
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-08-04T05:45:31.736731Z'
              type: subscription.expired
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.expired
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription expired webhook
  subscription.failed:
    post:
      description: Sent when a subscription fails
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: null
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 1000
                status: failed
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-08-04T05:45:31.736731Z'
              type: subscription.failed
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.failed
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription failed webhook
  subscription.on_hold:
    post:
      description: Sent when a subscription is put on hold
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: null
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: john doe
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 420
                status: on_hold
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-07-23T12:01:51.506540Z'
              type: subscription.on_hold
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.on_hold
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription on hold webhook
  subscription.plan_changed:
    post:
      description: Sent when a subscription plan is changed
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: null
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 1000
                status: active
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-08-04T05:45:31.736731Z'
              type: subscription.plan_changed
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.plan_changed
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription plan changed webhook
  subscription.renewed:
    post:
      description: Sent when a subscription is renewed
      requestBody:
        content:
          application/json:
            example:
              business_id: bus_H4ekzPSlcg
              data:
                addons: []
                billing:
                  city: New York
                  country: US
                  state: New York
                  street: 11th Main
                  zipcode: '08002'
                cancel_at_next_billing_date: false
                cancelled_at: null
                created_at: '2025-06-23T11:57:59.125145Z'
                currency: USD
                customer:
                  customer_id: cus_8VbC6JDZzPEqfBPUdpj0K
                  email: test@acme.com
                  name: Test user
                discount_cycles_remaining: 3
                discount_id: null
                expires_at: null
                metadata: {}
                next_billing_date: '2025-08-23T12:01:14.672875Z'
                on_demand: false
                payload_type: Subscription
                payment_frequency_count: 1
                payment_frequency_interval: Month
                previous_billing_date: '2025-07-23T12:01:21.506021Z'
                product_id: pdt_RUST4raxbl0Rfe4VQi1z
                quantity: 1
                recurring_pre_tax_amount: 1000
                status: active
                subscription_id: sub_7EeHq2ewQuadropD2ra
                subscription_period_count: 10
                subscription_period_interval: Year
                tax_inclusive: false
                trial_period_days: 0
              timestamp: '2025-08-04T05:45:31.736731Z'
              type: subscription.renewed
            schema:
              properties:
                business_id:
                  description: The business identifier
                  type: string
                data:
                  allOf:
                    - $ref: '#/components/schemas/SubscriptionResponse'
                  description: Event-specific data
                  properties:
                    payload_type:
                      description: The type of payload in the data field
                      enum:
                        - Subscription
                      type: string
                  type: object
                timestamp:
                  description: The timestamp of when the event occurred
                  format: date-time
                  type: string
                type:
                  description: The event type
                  enum:
                    - subscription.renewed
                  type: string
              required:
                - business_id
                - type
                - timestamp
                - data
              type: object
        required: true
      responses:
        '200':
          description: Webhook received successfully
        '400':
          description: Invalid request
        '401':
          description: Invalid webhook signature
      summary: Subscription renewed webhook